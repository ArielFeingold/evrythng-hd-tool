{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/ariel_feingold/Developer/evrythng/node_modules/@babel/runtime/regenerator\");\n\n// EVRYTHNG JS SDK v4.7.2\n// (c) 2012-2017 EVRYTHNG Ltd. London / New York / San Francisco.\n// Released under the Apache Software License, Version 2.0.\n// For all details and usage:\n// https://github.com/evrythng/evrythng.js\n\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n!function (global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    } // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n\n\n    return;\n  } // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n\n\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  runtime.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n\n\n  runtime.awrap = function (arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value instanceof AwaitArgument) {\n          return Promise.resolve(value.arg).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype); // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          if (method === \"return\" || method === \"throw\" && delegate.iterator[method] === undefined) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null; // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n\n            var returnMethod = delegate.iterator[\"return\"];\n\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);\n\n          if (record.type === \"throw\") {\n            context.delegate = null; // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          } // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n\n\n          method = \"next\";\n          arg = undefined;\n          var info = record.arg;\n\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = arg;\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  runtime.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n      return ContinueSentinel;\n    }\n  };\n}( // Among the various tricks for obtaining a reference to the global\n// object, this seems to be the most reliable technique that does not\n// use indirect eval (which violates Content Security Policy).\ntypeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof self === \"object\" ? self : this);\n\n(function (root, factory) {\n  module.exports = factory(null, require('request'));\n})(this, function (XMLHttpRequest, request) {\n  /**\n   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n   * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n   */\n  //Going sloppy to avoid 'use strict' string cost, but strict practices should\n  //be followed.\n\n  /*global setTimeout: false */\n  var requirejs, require, define;\n\n  (function (undef) {\n    var main,\n        _req,\n        makeMap,\n        handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n      return hasOwn.call(obj, prop);\n    }\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n\n\n    function normalize(name, baseName) {\n      var nameParts,\n          nameSegment,\n          mapValue,\n          foundMap,\n          lastIndex,\n          foundI,\n          foundStarMap,\n          starI,\n          i,\n          j,\n          part,\n          normalizedBaseParts,\n          baseParts = baseName && baseName.split(\"/\"),\n          map = config.map,\n          starMap = map && map['*'] || {}; //Adjust any relative paths.\n\n      if (name) {\n        name = name.split('/');\n        lastIndex = name.length - 1; // If wanting node ID compatibility, strip .js from end\n        // of IDs. Have to do this here, and not in nameToUrl\n        // because node allows either .js or non .js to map\n        // to same file.\n\n        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n          name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n        } // Starts with a '.' so need the baseName\n\n\n        if (name[0].charAt(0) === '.' && baseParts) {\n          //Convert baseName to array, and lop off the last part,\n          //so that . matches that 'directory' and not name of the baseName's\n          //module. For instance, baseName of 'one/two/three', maps to\n          //'one/two/three.js', but we want the directory, 'one/two' for\n          //this normalization.\n          normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n          name = normalizedBaseParts.concat(name);\n        } //start trimDots\n\n\n        for (i = 0; i < name.length; i++) {\n          part = name[i];\n\n          if (part === '.') {\n            name.splice(i, 1);\n            i -= 1;\n          } else if (part === '..') {\n            // If at the start, or previous value is still ..,\n            // keep them so that when converted to a path it may\n            // still work when converted to a path, even though\n            // as an ID it is less than ideal. In larger point\n            // releases, may be better to just kick out an error.\n            if (i === 0 || i === 1 && name[2] === '..' || name[i - 1] === '..') {\n              continue;\n            } else if (i > 0) {\n              name.splice(i - 1, 2);\n              i -= 2;\n            }\n          }\n        } //end trimDots\n\n\n        name = name.join('/');\n      } //Apply map config if available.\n\n\n      if ((baseParts || starMap) && map) {\n        nameParts = name.split('/');\n\n        for (i = nameParts.length; i > 0; i -= 1) {\n          nameSegment = nameParts.slice(0, i).join(\"/\");\n\n          if (baseParts) {\n            //Find the longest baseName segment match in the config.\n            //So, do joins on the biggest to smallest lengths of baseParts.\n            for (j = baseParts.length; j > 0; j -= 1) {\n              mapValue = map[baseParts.slice(0, j).join('/')]; //baseName segment has  config, find if it has one for\n              //this name.\n\n              if (mapValue) {\n                mapValue = mapValue[nameSegment];\n\n                if (mapValue) {\n                  //Match, update name to the new value.\n                  foundMap = mapValue;\n                  foundI = i;\n                  break;\n                }\n              }\n            }\n          }\n\n          if (foundMap) {\n            break;\n          } //Check for a star map match, but just hold on to it,\n          //if there is a shorter segment match later in a matching\n          //config, then favor over this star map.\n\n\n          if (!foundStarMap && starMap && starMap[nameSegment]) {\n            foundStarMap = starMap[nameSegment];\n            starI = i;\n          }\n        }\n\n        if (!foundMap && foundStarMap) {\n          foundMap = foundStarMap;\n          foundI = starI;\n        }\n\n        if (foundMap) {\n          nameParts.splice(0, foundI, foundMap);\n          name = nameParts.join('/');\n        }\n      }\n\n      return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n      return function () {\n        //A version of a require function that passes a moduleName\n        //value for items that may need to\n        //look up paths relative to the moduleName\n        var args = aps.call(arguments, 0); //If first arg is not require('string'), and there is only\n        //one arg, it is the array form without a callback. Insert\n        //a null so that the following concat is correct.\n\n        if (typeof args[0] !== 'string' && args.length === 1) {\n          args.push(null);\n        }\n\n        return _req.apply(undef, args.concat([relName, forceSync]));\n      };\n    }\n\n    function makeNormalize(relName) {\n      return function (name) {\n        return normalize(name, relName);\n      };\n    }\n\n    function makeLoad(depName) {\n      return function (value) {\n        defined[depName] = value;\n      };\n    }\n\n    function callDep(name) {\n      if (hasProp(waiting, name)) {\n        var args = waiting[name];\n        delete waiting[name];\n        defining[name] = true;\n        main.apply(undef, args);\n      }\n\n      if (!hasProp(defined, name) && !hasProp(defining, name)) {\n        throw new Error('No ' + name);\n      }\n\n      return defined[name];\n    } //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n\n\n    function splitPrefix(name) {\n      var prefix,\n          index = name ? name.indexOf('!') : -1;\n\n      if (index > -1) {\n        prefix = name.substring(0, index);\n        name = name.substring(index + 1, name.length);\n      }\n\n      return [prefix, name];\n    } //Creates a parts array for a relName where first part is plugin ID,\n    //second part is resource ID. Assumes relName has already been normalized.\n\n\n    function makeRelParts(relName) {\n      return relName ? splitPrefix(relName) : [];\n    }\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n\n\n    makeMap = function makeMap(name, relParts) {\n      var plugin,\n          parts = splitPrefix(name),\n          prefix = parts[0],\n          relResourceName = relParts[1];\n      name = parts[1];\n\n      if (prefix) {\n        prefix = normalize(prefix, relResourceName);\n        plugin = callDep(prefix);\n      } //Normalize according\n\n\n      if (prefix) {\n        if (plugin && plugin.normalize) {\n          name = plugin.normalize(name, makeNormalize(relResourceName));\n        } else {\n          name = normalize(name, relResourceName);\n        }\n      } else {\n        name = normalize(name, relResourceName);\n        parts = splitPrefix(name);\n        prefix = parts[0];\n        name = parts[1];\n\n        if (prefix) {\n          plugin = callDep(prefix);\n        }\n      } //Using ridiculous property names for space reasons\n\n\n      return {\n        f: prefix ? prefix + '!' + name : name,\n        //fullName\n        n: name,\n        pr: prefix,\n        p: plugin\n      };\n    };\n\n    function makeConfig(name) {\n      return function () {\n        return config && config.config && config.config[name] || {};\n      };\n    }\n\n    handlers = {\n      require: function require(name) {\n        return makeRequire(name);\n      },\n      exports: function exports(name) {\n        var e = defined[name];\n\n        if (typeof e !== 'undefined') {\n          return e;\n        } else {\n          return defined[name] = {};\n        }\n      },\n      module: function module(name) {\n        return {\n          id: name,\n          uri: '',\n          exports: defined[name],\n          config: makeConfig(name)\n        };\n      }\n    };\n\n    main = function main(name, deps, callback, relName) {\n      var cjsModule,\n          depName,\n          ret,\n          map,\n          i,\n          relParts,\n          args = [],\n          callbackType = typeof callback,\n          usingExports; //Use name if no relName\n\n      relName = relName || name;\n      relParts = makeRelParts(relName); //Call the callback to define the module, if necessary.\n\n      if (callbackType === 'undefined' || callbackType === 'function') {\n        //Pull out the defined dependencies and pass the ordered\n        //values to the callback.\n        //Default to [require, exports, module] if no deps\n        deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n\n        for (i = 0; i < deps.length; i += 1) {\n          map = makeMap(deps[i], relParts);\n          depName = map.f; //Fast path CommonJS standard dependencies.\n\n          if (depName === \"require\") {\n            args[i] = handlers.require(name);\n          } else if (depName === \"exports\") {\n            //CommonJS module spec 1.1\n            args[i] = handlers.exports(name);\n            usingExports = true;\n          } else if (depName === \"module\") {\n            //CommonJS module spec 1.1\n            cjsModule = args[i] = handlers.module(name);\n          } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {\n            args[i] = callDep(depName);\n          } else if (map.p) {\n            map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n            args[i] = defined[depName];\n          } else {\n            throw new Error(name + ' missing ' + depName);\n          }\n        }\n\n        ret = callback ? callback.apply(defined[name], args) : undefined;\n\n        if (name) {\n          //If setting exports via \"module\" is in play,\n          //favor that over return value and exports. After that,\n          //favor a non-undefined return value over exports use.\n          if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {\n            defined[name] = cjsModule.exports;\n          } else if (ret !== undef || !usingExports) {\n            //Use the return value from the function.\n            defined[name] = ret;\n          }\n        }\n      } else if (name) {\n        //May just be an object definition for the module. Only\n        //worry about defining if have a module name.\n        defined[name] = callback;\n      }\n    };\n\n    requirejs = require = _req = function req(deps, callback, relName, forceSync, alt) {\n      if (typeof deps === \"string\") {\n        if (handlers[deps]) {\n          //callback in this case is really relName\n          return handlers[deps](callback);\n        } //Just return the module wanted. In this scenario, the\n        //deps arg is the module name, and second arg (if passed)\n        //is just the relName.\n        //Normalize module name, if it contains . or ..\n\n\n        return callDep(makeMap(deps, makeRelParts(callback)).f);\n      } else if (!deps.splice) {\n        //deps is a config object, not an array.\n        config = deps;\n\n        if (config.deps) {\n          _req(config.deps, config.callback);\n        }\n\n        if (!callback) {\n          return;\n        }\n\n        if (callback.splice) {\n          //callback is an array, which means it is a dependency list.\n          //Adjust args if there are dependencies\n          deps = callback;\n          callback = relName;\n          relName = null;\n        } else {\n          deps = undef;\n        }\n      } //Support require(['a'])\n\n\n      callback = callback || function () {}; //If relName is a function, it is an errback handler,\n      //so remove it.\n\n\n      if (typeof relName === 'function') {\n        relName = forceSync;\n        forceSync = alt;\n      } //Simulate async callback;\n\n\n      if (forceSync) {\n        main(undef, deps, callback, relName);\n      } else {\n        //Using a non-zero value because of concern for what old browsers\n        //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n        //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n        //If want a value immediately, use require('id') instead -- something\n        //that works in almond on the global level, but not guaranteed and\n        //unlikely to work in other AMD implementations.\n        setTimeout(function () {\n          main(undef, deps, callback, relName);\n        }, 4);\n      }\n\n      return _req;\n    };\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n\n\n    _req.config = function (cfg) {\n      return _req(cfg);\n    };\n    /**\n     * Expose module registry for debugging and tooling\n     */\n\n\n    requirejs._defined = defined;\n\n    define = function define(name, deps, callback) {\n      if (typeof name !== 'string') {\n        throw new Error('See almond README: incorrect module build, no module name');\n      } //This module may not have dependencies\n\n\n      if (!deps.splice) {\n        //deps is not an array, so probably means\n        //an object literal or factory function for\n        //the value. Adjust args.\n        callback = deps;\n        deps = [];\n      }\n\n      if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n        waiting[name] = [name, deps, callback];\n      }\n    };\n\n    define.amd = {\n      jQuery: true\n    };\n  })();\n\n  define(\"almond\", function () {});\n  /*! Native Promise Only\n      v0.7.8-a (c) Kyle Simpson\n      MIT License: http://getify.mit-license.org\n  */\n\n  (function UMD(name, context, definition) {\n    // special form of UMD for polyfilling across evironments\n    context[name] = context[name] || definition();\n\n    if (typeof define == \"function\" && define.amd) {\n      define('promise', [], function $AMD$() {\n        return context[name];\n      });\n    } else if (typeof module != \"undefined\" && module.exports) {\n      module.exports = context[name];\n    }\n  })(\"Promise\", typeof global != \"undefined\" ? global : this, function DEF() {\n    /*jshint validthis:true */\n    \"use strict\";\n\n    var builtInProp,\n        cycle,\n        scheduling_queue,\n        ToString = Object.prototype.toString,\n        timer = typeof setImmediate != \"undefined\" ? function timer(fn) {\n      return setImmediate(fn);\n    } : setTimeout; // dammit, IE8.\n\n    try {\n      Object.defineProperty({}, \"x\", {});\n\n      builtInProp = function builtInProp(obj, name, val, config) {\n        return Object.defineProperty(obj, name, {\n          value: val,\n          writable: true,\n          configurable: config !== false\n        });\n      };\n    } catch (err) {\n      builtInProp = function builtInProp(obj, name, val) {\n        obj[name] = val;\n        return obj;\n      };\n    } // Note: using a queue instead of array for efficiency\n\n\n    scheduling_queue = function Queue() {\n      var first, last, item;\n\n      function Item(fn, self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n      }\n\n      return {\n        add: function add(fn, self) {\n          item = new Item(fn, self);\n\n          if (last) {\n            last.next = item;\n          } else {\n            first = item;\n          }\n\n          last = item;\n          item = void 0;\n        },\n        drain: function drain() {\n          var f = first;\n          first = last = cycle = void 0;\n\n          while (f) {\n            f.fn.call(f.self);\n            f = f.next;\n          }\n        }\n      };\n    }();\n\n    function schedule(fn, self) {\n      scheduling_queue.add(fn, self);\n\n      if (!cycle) {\n        cycle = timer(scheduling_queue.drain);\n      }\n    } // promise duck typing\n\n\n    function isThenable(o) {\n      var _then,\n          o_type = typeof o;\n\n      if (o != null && (o_type == \"object\" || o_type == \"function\")) {\n        _then = o.then;\n      }\n\n      return typeof _then == \"function\" ? _then : false;\n    }\n\n    function notify() {\n      for (var i = 0; i < this.chain.length; i++) {\n        notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);\n      }\n\n      this.chain.length = 0;\n    } // NOTE: This is a separate function to isolate\n    // the `try..catch` so that other code can be\n    // optimized better\n\n\n    function notifyIsolated(self, cb, chain) {\n      var ret, _then;\n\n      try {\n        if (cb === false) {\n          chain.reject(self.msg);\n        } else {\n          if (cb === true) {\n            ret = self.msg;\n          } else {\n            ret = cb.call(void 0, self.msg);\n          }\n\n          if (ret === chain.promise) {\n            chain.reject(TypeError(\"Promise-chain cycle\"));\n          } else if (_then = isThenable(ret)) {\n            _then.call(ret, chain.resolve, chain.reject);\n          } else {\n            chain.resolve(ret);\n          }\n        }\n      } catch (err) {\n        chain.reject(err);\n      }\n    }\n\n    function resolve(msg) {\n      var _then,\n          def_wrapper,\n          self = this; // already triggered?\n\n\n      if (self.triggered) {\n        return;\n      }\n\n      self.triggered = true; // unwrap\n\n      if (self.def) {\n        self = self.def;\n      }\n\n      try {\n        if (_then = isThenable(msg)) {\n          def_wrapper = new MakeDefWrapper(self);\n\n          _then.call(msg, function $resolve$() {\n            resolve.apply(def_wrapper, arguments);\n          }, function $reject$() {\n            reject.apply(def_wrapper, arguments);\n          });\n        } else {\n          self.msg = msg;\n          self.state = 1;\n\n          if (self.chain.length > 0) {\n            schedule(notify, self);\n          }\n        }\n      } catch (err) {\n        reject.call(def_wrapper || new MakeDefWrapper(self), err);\n      }\n    }\n\n    function reject(msg) {\n      var self = this; // already triggered?\n\n      if (self.triggered) {\n        return;\n      }\n\n      self.triggered = true; // unwrap\n\n      if (self.def) {\n        self = self.def;\n      }\n\n      self.msg = msg;\n      self.state = 2;\n\n      if (self.chain.length > 0) {\n        schedule(notify, self);\n      }\n    }\n\n    function iteratePromises(Constructor, arr, resolver, rejecter) {\n      for (var idx = 0; idx < arr.length; idx++) {\n        (function IIFE(idx) {\n          Constructor.resolve(arr[idx]).then(function $resolver$(msg) {\n            resolver(idx, msg);\n          }, rejecter);\n        })(idx);\n      }\n    }\n\n    function MakeDefWrapper(self) {\n      this.def = self;\n      this.triggered = false;\n    }\n\n    function MakeDef(self) {\n      this.promise = self;\n      this.state = 0;\n      this.triggered = false;\n      this.chain = [];\n      this.msg = void 0;\n    }\n\n    function Promise(executor) {\n      if (typeof executor != \"function\") {\n        throw TypeError(\"Not a function\");\n      }\n\n      if (this.__NPO__ !== 0) {\n        throw TypeError(\"Not a promise\");\n      } // instance shadowing the inherited \"brand\"\n      // to signal an already \"initialized\" promise\n\n\n      this.__NPO__ = 1;\n      var def = new MakeDef(this);\n\n      this[\"then\"] = function then(success, failure) {\n        var o = {\n          success: typeof success == \"function\" ? success : true,\n          failure: typeof failure == \"function\" ? failure : false\n        }; // Note: `then(..)` itself can be borrowed to be used against\n        // a different promise constructor for making the chained promise,\n        // by substituting a different `this` binding.\n\n        o.promise = new this.constructor(function extractChain(resolve, reject) {\n          if (typeof resolve != \"function\" || typeof reject != \"function\") {\n            throw TypeError(\"Not a function\");\n          }\n\n          o.resolve = resolve;\n          o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n          schedule(notify, def);\n        }\n\n        return o.promise;\n      };\n\n      this[\"catch\"] = function $catch$(failure) {\n        return this.then(void 0, failure);\n      };\n\n      try {\n        executor.call(void 0, function publicResolve(msg) {\n          resolve.call(def, msg);\n        }, function publicReject(msg) {\n          reject.call(def, msg);\n        });\n      } catch (err) {\n        reject.call(def, err);\n      }\n    }\n\n    var PromisePrototype = builtInProp({}, \"constructor\", Promise,\n    /*configurable=*/\n    false); // Note: Android 4 cannot use `Object.defineProperty(..)` here\n\n    Promise.prototype = PromisePrototype; // built-in \"brand\" to signal an \"uninitialized\" promise\n\n    builtInProp(PromisePrototype, \"__NPO__\", 0,\n    /*configurable=*/\n    false);\n    builtInProp(Promise, \"resolve\", function Promise$resolve(msg) {\n      var Constructor = this; // spec mandated checks\n      // note: best \"isPromise\" check that's practical for now\n\n      if (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n        return msg;\n      }\n\n      return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n\n        resolve(msg);\n      });\n    });\n    builtInProp(Promise, \"reject\", function Promise$reject(msg) {\n      return new this(function executor(resolve, reject) {\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n\n        reject(msg);\n      });\n    });\n    builtInProp(Promise, \"all\", function Promise$all(arr) {\n      var Constructor = this; // spec mandated checks\n\n      if (ToString.call(arr) != \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n      }\n\n      if (arr.length === 0) {\n        return Constructor.resolve([]);\n      }\n\n      return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n\n        var len = arr.length,\n            msgs = Array(len),\n            count = 0;\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n          msgs[idx] = msg;\n\n          if (++count === len) {\n            resolve(msgs);\n          }\n        }, reject);\n      });\n    });\n    builtInProp(Promise, \"race\", function Promise$race(arr) {\n      var Constructor = this; // spec mandated checks\n\n      if (ToString.call(arr) != \"[object Array]\") {\n        return Constructor.reject(TypeError(\"Not an array\"));\n      }\n\n      return new Constructor(function executor(resolve, reject) {\n        if (typeof resolve != \"function\" || typeof reject != \"function\") {\n          throw TypeError(\"Not a function\");\n        }\n\n        iteratePromises(Constructor, arr, function resolver(idx, msg) {\n          resolve(msg);\n        }, reject);\n      });\n    });\n    return Promise;\n  }); // ## UTILS.JS\n  // **The Utils module provide a set of utility methods used\n  // across the whole library. For that, it doesn't have any\n  // dependency.**\n\n\n  define('utils', ['promise'], function (Promise) {\n    'use strict';\n\n    return {\n      // Check if a reference is defined.\n      isDefined: function isDefined(value) {\n        return typeof value !== 'undefined';\n      },\n      // Check if a variable is a function.\n      isFunction: function isFunction(fn) {\n        return Object.prototype.toString.call(fn) == '[object Function]';\n      },\n      // Check if a variable is a string.\n      isString: function isString(str) {\n        return Object.prototype.toString.call(str) == '[object String]';\n      },\n      // Check if a variable is an array.\n      isArray: function isArray(arr) {\n        return Object.prototype.toString.call(arr) == '[object Array]';\n      },\n      // Check if a variable is an Object (includes Object functions and\n      // plain objects)\n      isObject: function isObject(obj) {\n        return obj === Object(obj) && !this.isArray(obj);\n      },\n      // Simple and shallow extend method, used to extend an object's properties\n      // with another object's. The `override` parameter defines if the\n      // source object should be overriden or if this method should return a new\n      // object (it is *false by default*).\n      extend: function extend(source, obj, override) {\n        var out; // Create extensible object.\n\n        if (override) {\n          out = source;\n        } else {\n          // Create shallow copy of source.\n          out = {};\n\n          for (var i in source) {\n            if (source.hasOwnProperty(i)) {\n              out[i] = source[i];\n            }\n          }\n        } // Copy properties.\n\n\n        for (var j in obj) {\n          if (obj.hasOwnProperty(j)) {\n            out[j] = obj[j];\n          }\n        }\n\n        return out;\n      },\n      // Curried version of extend function above, e.g:\n      // Utils.extend(source)(target);\n      extendCurried: function extendCurried(source) {\n        var $this = this;\n        return function (obj) {\n          return $this.extend(source, obj, true);\n        };\n      },\n      // Build URL query string params out of a javascript object.\n      // Encode key and value components as they are appended to query string.\n      buildParams: function buildParams(params, noEncode) {\n        if (this.isObject(params)) {\n          var paramsStr = [];\n\n          for (var key in params) {\n            if (params.hasOwnProperty(key) && params[key] !== undefined) {\n              var value = this.isObject(params[key]) ? this.buildParams(params[key], true) : params[key];\n              paramsStr.push((noEncode ? key : encodeURIComponent(key)) + '=' + (noEncode ? this.escapeSpecials(value) : encodeURIComponent(value)));\n            }\n          } // Build string from the array.\n\n\n          return paramsStr.join('&');\n        } else {\n          return params;\n        }\n      },\n      // Build full URL from a base url and params, if there are any.\n      buildUrl: function buildUrl(options) {\n        var url = options.apiUrl + (options.url ? options.url : '');\n\n        if (options.params) {\n          url += (url.indexOf('?') === -1 ? '?' : '&') + this.buildParams(options.params);\n        }\n\n        return url;\n      },\n      // Get current position using HTML5 Geolocation and resolve promise\n      // once it has returned.\n      getCurrentPosition: function getCurrentPosition(options) {\n        if (typeof window !== 'undefined' && window.navigator.geolocation) {\n          // Have default options, but allow to extend with custom.\n          var geolocationOptions = this.extend({\n            maximumAge: 0,\n            timeout: 10000,\n            enableHighAccuracy: true\n          }, options);\n          return new Promise(function (resolve, reject) {\n            window.navigator.geolocation.getCurrentPosition(function (position) {\n              resolve(position);\n            }, function (err) {\n              var errorMessage = 'Geolocation: ';\n\n              if (err.code === 1) {\n                errorMessage = 'You didn\\'t share your location.';\n              } else if (err.code === 2) {\n                errorMessage = 'Couldn\\'t detect your current location.';\n              } else if (err.code === 3) {\n                errorMessage = 'Retrieving position timed out.';\n              } else {\n                errorMessage = 'Unknown error.';\n              }\n\n              reject(errorMessage);\n            }, geolocationOptions);\n          });\n        } else {\n          return new Promise(function (resolve, reject) {\n            reject('Your browser\\/environment doesn\\'t support geolocation.');\n          });\n        }\n      },\n      // Escape special characters from a string (with \"\\\").\n      escapeSpecials: function escapeSpecials(input) {\n        // Specials to be escaped by default.\n        var specials = ['&', '|', '!', '>', '<', '=', '~', '(', ')', ','];\n        var specialsRegex = new RegExp('[' + specials.join('\\\\') + ']', 'g');\n\n        if (input && typeof input === 'string') {\n          input = input.replace(specialsRegex, '\\\\$&');\n        }\n\n        return input;\n      },\n      // Parse Link headers for API pagination.\n      // https://gist.github.com/niallo/3109252\n      parseLinkHeader: function parseLinkHeader(header) {\n        var links = {};\n\n        if (header && header.length) {\n          // Split parts by comma\n          var parts = header.split(','); // Parse each part into a named link\n\n          for (var i = 0; i < parts.length; i++) {\n            var section = parts[i].split(';');\n\n            if (section.length !== 2) {\n              throw new Error(\"section could not be split on ';'\");\n            }\n\n            var url = section[0].replace(/<(.*)>/, '$1').trim();\n            var name = section[1].replace(/rel=\"(.*)\"/, '$1').trim();\n            links[name] = url;\n          }\n        }\n\n        return links;\n      },\n      // Iterate over *Iterator*.\n      // https://gist.github.com/jakearchibald/31b89cba627924972ad6\n      spawn: function spawn(iter) {\n        function continuer(verb, arg) {\n          var result;\n\n          try {\n            result = iter[verb](arg);\n          } catch (err) {\n            return Promise.reject(err);\n          }\n\n          if (result.done) {\n            return result.value;\n          } else {\n            return Promise.resolve(result.value).then(onFulfilled, onRejected);\n          }\n        }\n\n        var onFulfilled = continuer.bind(continuer, \"next\");\n        var onRejected = continuer.bind(continuer, \"throw\");\n        return onFulfilled();\n      },\n      // Iterate over *AsyncIterator* and execute given function for each value.\n      forEachAsync: function forEachAsync(iter, fn) {\n        return new Promise(function (resolve) {\n          var i = 0;\n\n          function next() {\n            return iter.next().then(function (result) {\n              if (result.done) {\n                return result.value;\n              }\n\n              fn(result.value, i++);\n              return next();\n            });\n          }\n\n          resolve(next());\n        });\n      }\n    };\n  }); // ## CORE.JS\n  // **The Core module specifies the core EVT module and the client\n  // default settings. The library is built by adding functionality or\n  // sub-modules to EVT.**\n\n  define('core', ['utils'], function (Utils) {\n    'use strict'; // Version is updated from package.json using `grunt-version` on build.\n\n    var version = '4.7.2'; // Setup default settings:\n    // - _**apiUrl**: String - change the default API host_\n    // - _**fullResponse**: Boolean - by default the response of every call if the JSON\n    // body. However if you need to access the 'status' or 'responseHeaders' in responses\n    // set this to 'true'. The full response has the structure:_\n    // ```\n    //  {\n    //    data: <JSON data>,\n    //    headers: <response headers map>\n    //    status: <HTTP status code>\n    //  }\n    // ```\n    // - _**quiet**: Boolean - set to true if you don't want EVT.js to write anything to the console_\n    // - _**geolocation**: Boolean - set to true to ask for Geolocation when needed_\n    // - _**interceptors**: Array - each interceptor implements 'request' and/or 'response' functions\n    // that run before or after each HTTP call:_\n    // ```\n    //  var myInterceptor = {\n    //    request: function(options){\n    //      // do anything with options.data, options.headers, start spinner, etc.\n    //      return options;\n    //    },\n    //    response: function(result){\n    //      // do anything with result, stop spinner, etc. (can return promise)\n    //      return result;\n    //    }\n    //  }\n    // ```\n    // - _**timeout**: Integer - set the request timeout, in ms_\n    // - _**apiKey**: String - set the authorization API key used for all raw requests_\n\n    var defaultSettings = {\n      apiUrl: 'https://api.evrythng.com',\n      fullResponse: false,\n      quiet: false,\n      geolocation: true,\n      interceptors: []\n    }; // Module definition and raw API.\n\n    var EVT = {\n      version: version,\n      settings: defaultSettings,\n      Utils: Utils,\n      Entity: {},\n      // Setup method allows the developer to change overall settings for every\n      // subsequent request. However, these can be overridden for each request as well.\n      // Setup merges current settings with the new custom ones.\n      setup: function setup(customSettings) {\n        if (Utils.isObject(customSettings)) {\n          this.settings = Utils.extend(this.settings, customSettings);\n        } else {\n          throw new TypeError('Setup should be called with an options object.');\n        }\n\n        return this.settings;\n      },\n      // Use the passed plugin features by requiring its dependencies and installing it.\n      use: function use(plugin) {\n        if (Utils.isObject(plugin) && Utils.isFunction(plugin.install)) {\n          var installArgs = []; // Inject plugin dependencies as requested, using the synchronous\n          // require API for Require.js and Almond.js.\n\n          if (plugin.$inject) {\n            plugin.$inject.forEach(function (dependency) {\n              installArgs.push(require(dependency));\n            });\n          }\n\n          plugin.install.apply(plugin, installArgs);\n          return this;\n        } else {\n          throw new TypeError('Plugin must implement \\'install()\\' method.');\n        }\n      }\n    };\n    return EVT;\n  }); // ## LOGGER.JS\n  // **The Logger module is simple wrapper for console log\n  // that prefixes EvrythngJS's logs with a custom header.**\n\n  define('logger', ['core'], function (EVT) {\n    'use strict';\n\n    var header = 'EvrythngJS';\n    return {\n      error: function error(data) {\n        if (EVT.settings.quiet === false) {\n          console.error(header + ' Error:', data);\n        }\n      },\n      info: function info(data) {\n        if (EVT.settings.quiet === false) {\n          console.info(header + ' Info:', data);\n        }\n      },\n      // TODO remove when callbacks deprecated\n      warnCallbackDeprecation: function warnCallbackDeprecation() {\n        if (EVT.settings.quiet === false) {\n          console.warn(header + ' Warning: Callbacks are deprecated, and are scheduled to be ' + 'removed in the next major release of the library. Please, use the Promise API instead.');\n        }\n      }\n    };\n  }); // ## REQUEST.JS\n\n  define('network/request', ['core', 'promise', 'utils', 'logger'], function (EVT, Promise, Utils, Logger) {\n    'use strict'; // Helper method used to build the returned response. It wraps the 'status' and 'headers' in an object in\n    // case the flag `fullResponse` is enabled as a global in `EVT.settings` or in this particular request.\n    // *200 OK* responses without data, return *null*.\n\n    function _buildResponse(res, fullResponse) {\n      var headers = res.headers,\n          response = res.body || null;\n\n      if (response) {\n        var contentType = headers['content-type'];\n\n        if (contentType && contentType.indexOf('application/json') !== -1) {\n          // try to parse the response if looks like json\n          try {\n            response = JSON.parse(response);\n          } catch (e) {}\n        }\n      }\n\n      if (fullResponse) {\n        response = {\n          data: response,\n          headers: headers,\n          status: res.statusCode\n        }; // If any errors received, pull them to top level\n\n        if (response.data && response.data.errors) {\n          response.errors = response.data.errors;\n          delete response.data.errors;\n        }\n      }\n\n      return response;\n    } // Forward EVRYTHNG API error and extend with URL and Method.\n\n\n    function _buildError(req, url, method, response) {\n      var errorData = response || {};\n      errorData.status = req.statusCode;\n      errorData.url = url;\n      errorData.method = method;\n      return errorData;\n    }\n\n    function node(options, successCallback, errorCallback) {\n      options = options || {};\n      var url = Utils.buildUrl(options),\n          method = options.method || 'get';\n      var requestOptions = {\n        url: url,\n        method: method,\n        headers: options.headers\n      };\n      requestOptions.body = options.data ? JSON.stringify(options.data) : null; // Set timeout.\n\n      if (options.timeout > 0) {\n        requestOptions.timeout = options.timeout;\n      }\n\n      return new Promise(function (resolve, reject) {\n        try {\n          request(requestOptions, function (error, response) {\n            if (error) {\n              // Request failed\n              reject(error);\n            } else {\n              // Request successful\n              var data = _buildResponse(response, options.fullResponse);\n\n              if (response.statusCode >= 200 && response.statusCode < 300) {\n                // Valid response\n                if (successCallback) {\n                  Logger.warnCallbackDeprecation();\n                  successCallback(data);\n                }\n\n                resolve(data);\n              } else {\n                // API error - forward it\n                var errorData = _buildError(response, url, method, data);\n\n                if (errorCallback) {\n                  Logger.warnCallbackDeprecation();\n                  errorCallback(errorData);\n                }\n\n                reject(errorData);\n              }\n            }\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n\n    return node;\n  }); // ## HTTP.JS\n  // It controls the raw request to the API, using the \"request\" node module.**\n\n  define('transport', ['network/request'], function (node) {\n    'use strict';\n\n    return function (requestOptions, successCb, errorCb) {\n      var response; // Returns a promise\n\n      if (typeof request === 'function') {\n        response = node(requestOptions, successCb, errorCb);\n      } else {\n        throw new Error('Request module not available.');\n      }\n\n      return response;\n    };\n  }); // ## API.JS\n  // **The API module attaches the api() method to the EVT module.\n\n  define('api', ['core', 'transport', 'promise', 'utils'], function (EVT, transport, Promise, Utils) {\n    'use strict'; // The api() method or EVT.api() returns a **Promise**. Nevertheless,\n    // it still allows the old-styled callback API as follows:\n    // - **EVT.api(options)** - options object can contain `success` or `error`\n    // properties to define success and error callbacks\n    // - **EVT.api(options, successCb, errorCb)**\n    // Options available are:\n    // ```\n    // fullResponse - override fullResponse global setting (see module `core`)\n    // apiUrl - override default `EVT.settings.apiUrl`\n    // url - URL of the request, relative to `EVT.settings.apiUrl`\n    // method - HTTP method, default: `GET`\n    // authorization - Authorization header content, should contain API Key\n    // success - success handler function\n    // error - error handler function\n    // interceptors - override interceptors pipeline. If you want to extend, use:\n    //    interceptors: EVT.settings.interceptors.concat([{...}])\n    // ```\n\n    function api(options, successCallback, errorCallback) {\n      // Merge options with defaults setup in `EVT.settings`.\n      var requestOptions = Utils.extend({\n        apiUrl: EVT.settings.apiUrl,\n        url: '',\n        fullResponse: EVT.settings.fullResponse,\n        authorization: EVT.settings.apiKey || EVT.settings.authorization,\n        timeout: EVT.settings.timeout,\n        interceptors: EVT.settings.interceptors\n      }, options); // Merge nested headers object. Allow users to use both `options.authorization`\n      // and `options.headers.authorization`.\n\n      requestOptions.headers = Utils.extend({\n        authorization: requestOptions.authorization,\n        accept: '*/*',\n        'content-type': 'application/json'\n      }, options.headers); // Setup callbacks giving priority to parameters.\n\n      var successCb,\n          errorCb,\n          cancelled = false,\n          request,\n          response;\n      request = Promise.resolve(requestOptions);\n\n      if (Utils.isFunction(successCallback)) {\n        successCb = successCallback;\n      } else if (options && Utils.isFunction(options.success)) {\n        successCb = options.success;\n      }\n\n      if (Utils.isFunction(errorCallback)) {\n        errorCb = errorCallback;\n      } else if (options && Utils.isFunction(options.error)) {\n        errorCb = options.error;\n      } // Cancel request, simply adds the flag to be processed afterwards.\n\n\n      function cancel() {\n        cancelled = true;\n      } // Apply request interceptors\n\n\n      if (Utils.isArray(requestOptions.interceptors)) {\n        requestOptions.interceptors.forEach(function (interceptor) {\n          if (interceptor.request && Utils.isFunction(interceptor.request)) {\n            // Chain promises\n            request = request.then(function (requestOptions) {\n              if (cancelled) {\n                return requestOptions;\n              }\n\n              return interceptor.request(requestOptions, cancel) || requestOptions;\n            });\n          }\n        });\n      }\n\n      return request.then(function (requestOptions) {\n        // Reject request if it has been cancelled by request interceptors.\n        if (cancelled) {\n          return Promise.reject({\n            errors: ['Request cancelled on request interceptors.'],\n            cancelled: true\n          });\n        }\n\n        response = transport(requestOptions, successCb, errorCb); // Apply response interceptors\n\n        if (Utils.isArray(requestOptions.interceptors)) {\n          requestOptions.interceptors.forEach(function (interceptor) {\n            if (interceptor.response && Utils.isFunction(interceptor.response)) {\n              // Chain promises\n              response = response.then(interceptor.response);\n            }\n          });\n        }\n\n        return response;\n      });\n    } // Attach api method to the EVT module.\n\n\n    EVT.api = api;\n    return EVT;\n  }); // ## SCOPE.JS\n  // **Scope defines the context in which API calls are made.\n  // Thus, it stores its defining API Key. Scopes send their\n  // respective `API Key` in their request's `Authorization` header.**\n  // *For example, reads on products using ApplicationScope or\n  // EVT.App only return the products created for that specific\n  // application/scope.*\n\n  define('scope/scope', ['core', 'utils'], function (EVT, Utils) {\n    'use strict'; // Scope super class constructor:\n    // - _**new Scope(apiKey)** - API Key string_\n\n    var Scope = function Scope(apiKey) {\n      // Default parent scope does not have parent.\n      this.parentScope = null; // Setup apiKey of the current Scope if it is a String.\n\n      if (Utils.isString(apiKey)) {\n        this.apiKey = apiKey;\n      } else {\n        throw new TypeError('Scope constructor should be called with API Key.');\n      }\n\n      this.$init = EVT.api({\n        url: '/access',\n        authorization: this.apiKey\n      });\n    }; // Return Scope factory function\n\n\n    return Scope;\n  });\n  define('iterator', ['utils'], function (Utils) {\n    'use strict';\n    /* jshint ignore:start */\n\n    return function (request) {\n      return _regeneratorRuntime.mark(function gen(options) {\n        var result, links, awaitResult;\n        return _regeneratorRuntime.async(function gen$(context$3$0) {\n          while (1) {\n            switch (context$3$0.prev = context$3$0.next) {\n              case 0:\n                awaitResult = function awaitResult(requestPromise) {\n                  return _regeneratorRuntime.async(function awaitResult$(context$4$0) {\n                    while (1) {\n                      switch (context$4$0.prev = context$4$0.next) {\n                        case 0:\n                          context$4$0.next = 2;\n                          return _regeneratorRuntime.awrap(requestPromise);\n\n                        case 2:\n                          result = context$4$0.sent;\n                          links = Utils.parseLinkHeader(result.headers.link);\n                          return context$4$0.abrupt(\"return\", result.data);\n\n                        case 5:\n                        case \"end\":\n                          return context$4$0.stop();\n                      }\n                    }\n                  }, null, this);\n                };\n\n                options = options || {}; // TODO: Remove when page API is fully deprecated.\n\n                options.params = Utils.extend({\n                  sortOrder: 'DESCENDING'\n                }, options.params);\n                context$3$0.next = 5;\n                return awaitResult(request.call(this, {\n                  url: this.path,\n                  fullResponse: true\n                }, options));\n\n              case 5:\n                if (!links.next) {\n                  context$3$0.next = 10;\n                  break;\n                }\n\n                context$3$0.next = 8;\n                return awaitResult(request.call(this, {\n                  apiUrl: decodeURIComponent(links.next),\n                  fullResponse: true\n                }));\n\n              case 8:\n                context$3$0.next = 5;\n                break;\n\n              case 10:\n              case \"end\":\n                return context$3$0.stop();\n            }\n          }\n        }, gen, this);\n      });\n    };\n    /* jshint ignore:end */\n  }); // ## RESOURCE.JS\n  // **The private Resource module setups up the base resource CRUD methods.\n  // All requests made on a resource are scoped, meaning they will send the\n  // resouce's owner scope's API Key.**\n  // **Another important feature is that if the resource has a class/entity, which\n  // it allows to serialize and deserialize requests and responses. Also, with the\n  // `fetchCascade` option enabled, an entity knows how to automatically fetch nested\n  // entities.**\n  // *For example, the result of a .read() can be a Thng entity, that has specific\n  // methods to update itself, get the corresponding product or manage properties.*\n\n  define('resource', ['core', 'promise', 'iterator', 'scope/scope', 'utils', 'logger'], function (EVT, Promise, iterator, Scope, Utils, Logger) {\n    'use strict'; // Resource constructor. As this is a private module, all resource constructors\n    // are called within scopes. It accepts:\n    // - _**scope**: scope that owns this resource (`EVT.App`, `EVT.User`)_\n    // - _**path**: relative path to `EVT.settings.apiUrl` of this resource.\n    // It can represent a list or a single object (e.g. '/thngs', '/thngs/1')_\n    // - _**classFn**: class of the current resource, used to serialize/deserialize\n    // requests/responses. If the response does not need special treatment and the\n    // JSON representation is enough, the classFn can be omitted._\n\n    var Resource = function Resource(scope, path, classFn) {\n      // Setup scope for each of the subsequent calls.\n      if (scope && scope instanceof Scope) {\n        this.scope = scope;\n      } else {\n        throw new TypeError('Scope should inherit from Scope (e.g. EVT.App).');\n      } // Setup path and allow to omit leading '/'.\n\n\n      if (Utils.isString(path)) {\n        if (path[0] != '/') {\n          path = '/' + path;\n        }\n\n        this.path = path;\n      } else {\n        throw new TypeError('Resource must have a String path.');\n      } // Setup class for serializing and deserializing results. It must implement\n      // a *toJSON()* method. This method is in the Entity prototype. Since all of our\n      // entities inherit from Entity, by default all of them will have this.\n\n\n      if (Utils.isFunction(classFn)) {\n        if (Utils.isFunction(classFn.prototype.toJSON)) {\n          this['class'] = classFn;\n        } else {\n          Logger.error('Class for resource \"' + path + '\" does not implement toJSON().');\n        }\n      } else {\n        Logger.info('Class for resource \"' + path + '\" undefined. It will not return ' + 'proper Entities nor cascaded Entities.');\n      }\n    }; // Helper method to prepare and handle a request giving the parameters passed to\n    // any of the resource methods. Allow to have callbacks as separate parameters or\n    // included in the options object, providing exactly the same interface as `EVT.api()`.\n\n\n    function _request(requestOptions, userOptions, successCallback, errorCallback) {\n      var successCb = successCallback,\n          errorCb = errorCallback,\n          request; // This verification allows not to pass any options, and have callbacks in\n      // its place. It also allows passing *null* if there is no success callback.\n\n      if (Utils.isFunction(userOptions) || userOptions === null) {\n        successCb = userOptions;\n        errorCb = successCallback;\n      } else if (Utils.isObject(userOptions)) {\n        // If options is an object, merge it with the request options. Callbacks\n        // can be included in this object or as separate parameters (same as\n        // `EVT.api()`).\n        requestOptions = Utils.extend(requestOptions, userOptions);\n      } // Use current scope's API key to perform the request.\n\n\n      requestOptions.authorization = this.scope.apiKey; // If parentScope is set to operator scope, use the operator API key.\n\n      if (EVT.Operator && this.scope.parentScope instanceof EVT.Operator) {\n        requestOptions.authorization = this.scope.parentScope.apiKey; // If we're working in application scope as an operator,\n        // we need to send the application id as a parameter.\n\n        if (this.scope instanceof EVT.App) {\n          requestOptions.params = requestOptions.params || {};\n          requestOptions.params.project = this.scope.project;\n        }\n      } // Actually make the request and handle its response, by forwarding to\n      // the raw `EVT.api()` method.\n\n\n      request = EVT.api(requestOptions, successCb, errorCb);\n      return _handleResponse.call(this, request);\n    } // Handle asynchronous requests based on the custom or default options.\n\n\n    function _handleResponse(request) {\n      var $this = this; // Before returning the response, parse it.\n      // This success handler is called inside the Promise, so we need to\n      // keep the current context.\n      // Also, By not providing an error interceptor, we will let the error\n      // propagate from `EVT.api()` to the `resource.read()` promise error\n      // handler\n\n      return request.then(function (response) {\n        return $this.parse(response);\n      });\n    } // ### Resource API\n    // Any resource create in a scope will inherit these methods. However, it\n    // is possible to add custom methods to a resource in a custom Entity\n    // *resourceConstructor* (e.g. refer to the [`entity/user` doc](entity/user.html),\n    // where a *.validate()* method is added to every User resource).\n    // **Remember that all CRUD methods forward to `EVT.api()` which returns a Promise.**\n    // #### Parse\n    // Parse a given response into an instance of this resource's\n    // class/entity, if possible. An entity always keeps a reference to its\n    // mother resource, in order to alias methods (e.g. the *entity.update()*\n    // method calls the mother *resource.update(entity.toJSON())* ).\n    // We expect the response to be one of these:\n    // * an object containing results (array of or single object) in \"data\",\n    // * an array of results\n    // * a single result object\n\n\n    Resource.prototype.parse = function (response) {\n      var parsedResponse = null;\n\n      if (this['class'] && response) {\n        var resource = this;\n\n        if (Utils.isArray(response)) {\n          // Response is array of results, parse to an array of entities.\n          parsedResponse = response.map(this.parse, this);\n        } else if (Utils.isObject(response)) {\n          if (response.hasOwnProperty('data')) {\n            // Full response - it is an object and includes \"data\", parse just the data.\n            parsedResponse = response;\n            parsedResponse.data = resource.parse(parsedResponse.data); // If response contains results count header, add a shortcut to it\n\n            if (Utils.isObject(parsedResponse.headers) && Utils.isString(parsedResponse.headers['x-result-count'])) {\n              parsedResponse.count = parseInt(parsedResponse.headers['x-result-count']);\n            }\n          } else {\n            // Response is a single result, parse to single entity.\n            var updatedPath = this.path,\n                updatedResource; // Add entity id to resource path. If it is already there - do nothing.\n\n            if (response.id) {\n              updatedPath += updatedPath.indexOf(response.id) === -1 ? '/' + response.id : '';\n            }\n\n            updatedResource = new Resource(this.scope, updatedPath, this['class']);\n            parsedResponse = new this['class'](response, updatedResource);\n          }\n        } else {\n          // Response is most likely a string, just forward it\n          parsedResponse = response;\n        }\n      } else {\n        // We don't have enough information to parse the response, so just forward it.\n        parsedResponse = response;\n      }\n\n      return parsedResponse;\n    }; // #### Jsonify\n    // The opposite of parse. It takes an entity and returns only the JSON\n    // part of it, used to make the calls to the REST API. If the passed object\n    // is a plain object, do nothing.\n\n\n    Resource.prototype.jsonify = function (classObject) {\n      if (this['class'] && classObject instanceof this['class']) {\n        return classObject.toJSON();\n      } else {\n        return classObject || {};\n      }\n    }; // #### Create\n    // Create sends a `POST` request to the REST API with the provided object data.\n    // It always returns an entity or JSON object on success. It accepts the\n    // following parameters:\n    // - _**create(data)**: just send data (entity or plain JSON), no options,\n    // no callbacks_\n    // - _**create(data, options)**: no callbacks or they are included in options_\n    // - _**create(data, options, successCb, errorCb)**: all explicit params_\n    // - _**create(data, successCb, errorCb)**: no options, just callbacks_\n\n\n    Resource.prototype.create = function (data, options, successCallback, errorCallback) {\n      if (!data || Utils.isFunction(data)) {\n        throw new TypeError('Create method should have payload.');\n      }\n\n      var requestOptions = {\n        url: this.path,\n        method: 'post',\n        data: this.jsonify(data)\n      };\n      return _request.call(this, requestOptions, options, successCallback, errorCallback);\n    }; // #### Read\n    // Read sends a `GET` request to the REST API. It always returns an entity\n    // or JSON object on success. It accepts the following parameters:\n    // - _**read()**: no options, no callbacks_\n    // - _**read(options)**: no callbacks or they are included in options_\n    // - _**read(options, successCb, errorCb)**: all explicit params_\n    // - _**read(successCb, errorCb)**: no options, just callbacks_\n\n\n    Resource.prototype.read = function (options, successCallback, errorCallback) {\n      var requestOptions = {\n        url: this.path\n      };\n      return _request.call(this, requestOptions, options, successCallback, errorCallback);\n    }; // #### Update\n    // Update sends a `PUT` request to the REST API. It always returns an entity\n    // or JSON object on success.\n    // **The interface is the same as _.create()_**\n\n\n    Resource.prototype.update = function (data, options, successCallback, errorCallback) {\n      var requestOptions = {\n        url: this.path,\n        method: 'put',\n        data: this.jsonify(data)\n      };\n      return _request.call(this, requestOptions, options, successCallback, errorCallback);\n    }; // #### Delete\n    // Delete sends a `DELETE` request to the REST API. It always returns an *null*\n    // response on success.\n    // **The interface is the same as _.read()_**\n\n\n    Resource.prototype['delete'] = function (options, successCallback, errorCallback) {\n      var requestOptions = {\n        url: this.path,\n        method: 'delete'\n      };\n      return _request.call(this, requestOptions, options, successCallback, errorCallback);\n    }; // #### Iterator\n    // Iterator is an async generator that cycles through all the 'pages' of a\n    // resource, yielding all the results asynchronously.\n    // Eventually, in ES7 (https://github.com/tc39/proposal-async-iteration),\n    // looping through all the items would become:\n    // ```javascript\n    // for await(let thngs of user.thng().iterator()){\n    //  console.log(thngs);\n    // }\n    // ```\n    // - _**iterator()**: no options_\n    // - _**iterator(options)**: forward options to initial request_\n\n\n    Resource.prototype.iterator = iterator(_request); // Given we don't have subclasses of Resource, this static factory method\n    // allows to generate a resource constructor given a path and class.\n    // By default all resource constructors receive a string ID for single\n    // entity resources.\n\n    Resource.constructorFactory = function (path, Entity, nestedResources) {\n      return function (id) {\n        var fullPath = path || \"\";\n\n        if (id) {\n          if (Utils.isString(id)) {\n            fullPath += '/' + encodeURIComponent(id);\n          } else {\n            throw new TypeError('ID must be a string.');\n          }\n        }\n\n        var resource = new Resource(this, fullPath, Entity);\n\n        if (nestedResources) {\n          // Allow nested resources in single call.\n          // E.g. users can access to a thng's nested data directly with:\n          //```\n          //  user.thng().property().read(...);\n          //  user.thng().action().read(...);\n          //```\n          // instead of fetching the Thng first.\n          var rawEntity = new Entity({\n            id: id\n          }, resource);\n\n          if (Utils.isArray(nestedResources)) {\n            nestedResources.forEach(function (nestedResource) {\n              // If the entity has it, then attach to this resource as well.\n              if (rawEntity[nestedResource]) {\n                resource[nestedResource] = function () {\n                  return rawEntity[nestedResource].apply(rawEntity, arguments);\n                };\n              }\n            });\n          } else {\n            throw new TypeError('Nested resources should be an array.');\n          }\n        }\n\n        return resource;\n      };\n    };\n\n    return Resource;\n  }); // ## ENTITY.JS\n  // **Entity is a private super class that implements base common methods for\n  // all Evrythng objects. It establishes the way objects are converted\n  // to JSON, and provide an *update()* and *delete()* method for all entities.**\n\n  define('entity/entity', ['resource', 'utils'], function (Resource, Utils) {\n    'use strict'; // The entity constructor, and therefore all the standard inheritances,\n    // accepts:\n    // - _**new Entity()**: create an empty entity_\n    // - _**new Entity(obj)**: entity with merged obj properties_\n    // - _**new Entity(resource)**: empty entity bound to a Resource_\n    // - _**new Entity(obj, resource)**: fully build entity bound to a Resource_\n    // *Nevertheless, an Entity without Resource cannot request any\n    // update or delete. It can however be passed to resources as\n    // 'payload' instead of JSON.*\n    // ```js\n    //  var prod = new EVT.Entity.Product({ foo: 'bar' };\n    //  // prod.update() // throws error\n    //  app.product().create(prod); // create product\n    // ```\n\n    var Entity = function Entity(objData, resource) {\n      if (Utils.isObject(objData)) {\n        if (objData instanceof Resource) {\n          this.resource = objData;\n        } else {\n          this.resource = resource;\n          Utils.extend(this, objData, true);\n        }\n      }\n    }; // Return the JSON object that is stored in engine. All non-function properties\n    // except *resource* are properties of the object.\n\n\n    Entity.prototype.toJSON = function () {\n      var json = {};\n\n      for (var prop in this) {\n        if (this.hasOwnProperty(prop)) {\n          if (Utils.isDefined(this[prop]) && !Utils.isFunction(this[prop]) && prop != 'resource') {\n            json[prop] = this[prop];\n          }\n        }\n      }\n\n      return json;\n    }; // Every entity can update itself via its resource reference. It does so by\n    // passing its JSON representation to the *resource.update()*.\n    // An entity update, as every request, returns a Promise. Although it also\n    // allows callbacks as:\n    // - _**update()**: simple update itself with modified properties_\n    // - _**update(obj)**: update itself with new properties_\n    // - _**update(obj, successCb, errorCb)**: previous, with callbacks_\n    // - _**update(successCb, errorCb)**: update itself and use callbacks_\n\n\n    Entity.prototype.update = function (obj) {\n      if (this.resource) {\n        var args = arguments,\n            $this = this; // No object is passed, shift arguments. Add its JSON representation\n        // as the first argument.\n\n        if (obj === null || !obj || Utils.isFunction(obj)) {\n          args = Array.prototype.slice.call(arguments, 0);\n          args.unshift(this.toJSON());\n        }\n\n        return this.resource.update.apply(this.resource, args).then(function (updated) {\n          // Update itself with the result and return raw response from API.\n          Utils.extend($this, updated, true);\n          return updated;\n        });\n      } else {\n        throw new Error('This entity has no resource');\n      }\n    }; // Delete method also accepts callbacks as:\n    // - _**delete()**: handle with promise_\n    // - _**delete(successCb, errorCb)**: handle with callbacks_\n\n\n    Entity.prototype['delete'] = function () {\n      if (this.resource) {\n        return this.resource['delete'].apply(this.resource, arguments);\n      } else {\n        throw new Error('This entity has no resource');\n      }\n    };\n\n    return Entity;\n  }); // ## PROPERTY.JS\n  // **Property is a common Entity for Thngs and Products. It is always a\n  // nested resource and allows some simplified parameters, easing the\n  // update of properties and making it more fluent/literal.**\n\n  define('entity/property', ['core', './entity', 'resource', 'utils'], function (EVT, Entity, Resource, Utils) {\n    'use strict'; // Setup Property inheritance from Entity.\n\n    var Property = function Property() {\n      Entity.apply(this, arguments);\n    };\n\n    Property.prototype = Object.create(Entity.prototype);\n    Property.prototype.constructor = Property; // The property update normalization of arguments allows to\n    // make easier and more intuitive calls, such as:\n    // - Single property update:\n    // ```\n    //  thng.property('status').update('off');\n    //  thng.property('status').update({\n    //    value: 'off'\n    //  });\n    // ```\n    // - Multi property update:\n    // ```\n    //  thng.property().update({\n    //    status: 'off',\n    //    level: '80'\n    //  });\n    // ```\n\n    function _normalizeArguments(args) {\n      var data = args[0];\n\n      if (Utils.isString(data) || typeof data === 'number' || typeof data === 'boolean') {\n        // Update single property using string.\n        args[0] = [{\n          value: data\n        }];\n      } else if (Utils.isObject(data)) {\n        if (Utils.isDefined(data.value)) {\n          // Update single property using object notation.\n          args[0] = [data];\n        } else {\n          // Update multiple properties, creating an object for\n          // each key-value pair.\n          args[0] = [];\n\n          for (var key in data) {\n            args[0].push({\n              key: key,\n              value: data[key]\n            });\n          }\n        }\n      }\n\n      return args;\n    } // Attach class to EVT module.\n\n\n    EVT.Entity.Property = Property;\n    return {\n      'class': Property,\n      resourceConstructor: function resourceConstructor(property) {\n        if (!this.resource) {\n          throw new Error('This Entity does not have a Resource.');\n        }\n\n        var path = this.resource.path + '/properties',\n            resource;\n\n        if (property) {\n          if (Utils.isString(property)) {\n            path += '/' + encodeURIComponent(property);\n          } else {\n            throw new TypeError('Property must be a key/name string');\n          }\n        }\n\n        resource = new Resource(this.resource.scope, path, EVT.Entity.Property); // Override property resource create/update to allow custom values params.\n        // See *_normalizeArguments()*.\n\n        resource.create = function () {\n          return Resource.prototype.create.apply(this, _normalizeArguments(arguments));\n        };\n\n        resource.update = function () {\n          return Resource.prototype.update.apply(this, _normalizeArguments(arguments));\n        };\n\n        return resource;\n      }\n    };\n  }); // ## ACTION.JS\n  // **The Action Entity represents an action in the Engine. It inherits\n  // from Entity and overload the resource's *create()* method to allow\n  // empty parameters (no payload).**\n\n  define('entity/action', ['core', './entity', 'scope/scope', 'resource', 'utils', 'logger'], function (EVT, Entity, Scope, Resource, Utils, Logger) {\n    'use strict'; // Setup Action inheritance from Entity.\n\n    var Action = function Action() {\n      Entity.apply(this, arguments);\n    };\n\n    Action.prototype = Object.create(Entity.prototype);\n    Action.prototype.constructor = Action; // If the action object is empty (or a callback), generate the\n    // simplest action object that just needs the type of the action,\n    // which can be obtained from the resource's path.\n\n    function _normalizeArguments(obj) {\n      var args = arguments;\n\n      if (!obj || Utils.isFunction(obj)) {\n        args = Array.prototype.slice.call(arguments, 0);\n        args.unshift({});\n      }\n\n      return args;\n    } // Add the given entity identifier to an object (params or data).\n\n\n    function _addEntityIdentifier(entity, obj) {\n      if (entity.constructor === EVT.Entity.Product) {\n        obj.product = entity.id;\n      } else if (entity.constructor === EVT.Entity.Thng) {\n        obj.thng = entity.id;\n      } else if (entity.constructor === EVT.Entity.Collection) {\n        obj.collection = entity.id;\n      }\n\n      return obj;\n    } // Set the Entity ID of the entity receiving the action as well\n    // as the specified action type in the action data.\n\n\n    function _fillAction(entity, actionObj, actionType) {\n      if (!(entity instanceof Scope) && !entity.id) {\n        throw new Error('This entity does not have an ID.');\n      }\n\n      var ret = actionObj;\n\n      if (Utils.isArray(actionObj)) {\n        ret = actionObj.map(function (singleAction) {\n          return _fillAction(entity, singleAction, actionType);\n        });\n      } else {\n        ret.type = actionType !== 'all' && actionType || actionObj.type || '';\n\n        _addEntityIdentifier(entity, ret);\n      }\n\n      return ret;\n    } // Use HTML5 geolocation if explicitly defined in the options\n    // or set in the global settings.\n\n\n    function _useBrowserGeolocation(options) {\n      return options && options.geolocation !== undefined ? options.geolocation : EVT.settings.geolocation;\n    } // Attach class to EVT module.\n\n\n    EVT.Entity.Action = Action; // Return the resource factory function. Actions have a custom *resource\n    // constructor* that needs an action type and allows an optional ID.\n    // - _**product.action('scans')**: creates path '/product/<id>/actions/scans'_\n    // - _**product.action('scans', '1')**: creates path '/product/<id>/actions/scans/1'_\n\n    return {\n      'class': Action,\n      resourceConstructor: function resourceConstructor(actionType, id) {\n        var path,\n            resource,\n            context = this,\n            scope = this instanceof Scope ? this : this.resource.scope;\n\n        if (actionType) {\n          if (Utils.isString(actionType)) {\n            var relativePath = '/actions/' + actionType; // Scopes use the absolute path, while Resources use the relative path.\n            // Devices create a Resource for its Thng dynamically, which makes them\n            // in fact behave like a Resource.\n\n            path = this instanceof Scope ? relativePath : this.resource.path + relativePath;\n          } else {\n            throw new TypeError('Action type must be a name string');\n          }\n        } else {\n          throw new TypeError('Action type cannot be empty.');\n        } // Create a resource constructor dynamically and call it with this action's ID.\n\n\n        resource = Resource.constructorFactory(path, EVT.Entity.Action).call(scope, id); // Overload Action resource *create()* method to allow empty object.\n\n        resource.create = function () {\n          var $this = this,\n              args = _normalizeArguments.apply(this, arguments);\n\n          args[0] = _fillAction(context, args[0], actionType); // If geolocation setting is turned on, get current position before\n          // registering the action in the Engine.\n\n          if (_useBrowserGeolocation(args[1])) {\n            return Utils.getCurrentPosition().then(function (position) {\n              args[0].location = {\n                latitude: position.coords.latitude,\n                longitude: position.coords.longitude\n              };\n              args[0].locationSource = 'sensor';\n              return Resource.prototype.create.apply($this, args);\n            }, function (err) {\n              // Unable to get position, just inform the reason in the console.\n              Logger.info(err);\n              return Resource.prototype.create.apply($this, args);\n            });\n          } else {\n            return Resource.prototype.create.apply($this, args);\n          }\n        };\n\n        return resource;\n      }\n    };\n  }); // ## PRODUCT.JS\n  // **The Product is a simple Entity subclass that provides a nested\n  // Property Resource.**\n\n  define('entity/product', ['core', './entity', 'resource', './property', './action', 'utils'], function (EVT, Entity, Resource, Property, Action, Utils) {\n    'use strict'; // Setup Product inheritance from Entity.\n\n    var Product = function Product() {\n      Entity.apply(this, arguments);\n    };\n\n    Product.prototype = Object.create(Entity.prototype);\n    Product.prototype.constructor = Product; // Extend Product API by exposing a Property Resource, allowing to\n    // manage the properties of this product with a resource pattern.\n    // Expose an Action resource as well, for managing Products actions.\n\n    Utils.extend(Product.prototype, {\n      property: Property.resourceConstructor,\n      action: Action.resourceConstructor\n    }, true); // Attach class to EVT module.\n\n    EVT.Entity.Product = Product;\n    return {\n      'class': Product,\n      resourceConstructor: Resource.constructorFactory('/products', EVT.Entity.Product, ['property', 'action'])\n    };\n  }); // ## USER.JS\n  // **The User entity represents the app users stored in the Engine.\n  // It inherits from Entity and adds a new resource's *validate()* method,\n  // as well as a *self.validate()* to allow to validate users.**\n\n  define('entity/user', ['core', './entity', 'resource', 'utils'], function (EVT, Entity, Resource, Utils) {\n    'use strict'; // Setup User inheritance from Entity.\n\n    var User = function User(objData) {\n      // Rename user object argument's *evrythngUser* property to\n      // entity-standard-*id*.\n      var args = arguments;\n\n      if (objData.evrythngUser) {\n        objData.id = objData.evrythngUser;\n        delete objData.evrythngUser;\n      }\n\n      args[0] = objData;\n      Entity.apply(this, args);\n    };\n\n    User.prototype = Object.create(Entity.prototype);\n    User.prototype.constructor = User; // The validate method sends a `POST` request to the validate\n    // endpoint of a new user. This is only valid when the User\n    // resource path is *'/auth/evrythng/users/1'*.\n\n    function _validate(activationCode) {\n      if (!activationCode || !Utils.isString(activationCode)) {\n        throw new Error('Activation code must be a string.');\n      }\n\n      if (this.type && this.type === 'anonymous') {\n        throw new Error(\"Anonymous users can't be validated.\");\n      }\n\n      var scope = this.scope,\n          path = this.path; // If validate is called from the entity, the scope is the\n      // resource's scope\n\n      if (this.id) {\n        scope = this.resource.scope;\n        path = this.resource.path + '/' + this.id;\n      } // Activate newly created user.\n\n\n      return EVT.api({\n        url: path + '/validate',\n        method: 'post',\n        authorization: scope.apiKey,\n        data: {\n          activationCode: activationCode\n        }\n      });\n    } // Create an anonymous user\n    // It's a somewhat different process since anonymous users are created\n    // \"good to go\", they don't need validation.\n\n\n    function _createAnonymousUser() {\n      var $this = this;\n      return EVT.api({\n        url: this.path,\n        method: 'post',\n        params: {\n          anonymous: true // must be set to create anonymous user\n\n        },\n        data: {},\n        authorization: this.scope.apiKey\n      }).then(function (access) {\n        // Create User Scope\n        return new EVT.User({\n          id: access.evrythngUser,\n          apiKey: access.evrythngApiKey,\n          type: 'anonymous'\n        }, $this.scope);\n      });\n    } // Extend User API to allow to validate itself.\n\n\n    Utils.extend(User.prototype, {\n      validate: function validate() {\n        return _validate.call(this, this.activationCode);\n      }\n    }, true); // Attach class to EVT module.\n\n    EVT.Entity.User = User; // The User resource constructor is a custom constructor that\n    // returns the constructor. This allows the path to be variable.\n    // GET '/users' and GET '/auth/evrythng/users' return the same\n    // entity structure but there are access and back-end differences.\n\n    return {\n      'class': User,\n      resourceConstructor: function resourceConstructor(customPath) {\n        var path = customPath || '/users'; // Return the factory function.\n\n        return function (id) {\n          var resource = Resource.constructorFactory(path, EVT.Entity.User).call(this, id); // Add *validate()* method to the resource as well\n\n          resource.validate = function () {\n            return _validate.apply(this, arguments);\n          }; // Overload update() method to disallow updating of anonymous users (they're read-only)\n\n\n          resource.update = function () {\n            if (this.scope.type && this.scope.type === 'anonymous') {\n              throw new Error(\"Anonymous users are read-only.\");\n            }\n\n            return Resource.prototype.update.apply(this, arguments);\n          }; // Overload User resource *create()* method to allow creating anonymous users\n\n\n          resource.create = function () {\n            var $this = this,\n                data = arguments[0]; // the \"anonymous\" argument has higher priority, rest will be ignored (consistent with API)\n\n            if (Utils.isObject(data) && data.anonymous === true) {\n              return _createAnonymousUser.call($this);\n            } else {\n              return Resource.prototype.create.call($this, data);\n            }\n          };\n\n          return resource;\n        };\n      }\n    };\n  }); // ## PLACE.JS\n  // **The Place is a simple Entity subclass representing the REST API\n  // Place object.**\n\n  define('entity/place', ['core', './entity', 'resource', 'scope/scope', 'utils', 'logger'], function (EVT, Entity, Resource, Scope, Utils, Logger) {\n    'use strict'; // Setup Place inheritance from Entity.\n\n    var Place = function Place() {\n      Entity.apply(this, arguments);\n    };\n\n    Place.prototype = Object.create(Entity.prototype);\n    Place.prototype.constructor = Place;\n\n    function _normalizeArguments(args) {\n      var data = args[0];\n\n      if (!data || Utils.isFunction(data)) {\n        // Add empty data object\n        args = Array.prototype.slice.call(args, 0);\n        args.unshift({});\n      }\n\n      return args;\n    } // Attach class to EVT module.\n\n\n    EVT.Entity.Place = Place;\n    return {\n      'class': Place,\n      resourceConstructor: function resourceConstructor(id) {\n        var resource = Resource.constructorFactory('/places', EVT.Entity.Place).call(this, id); // Overload resource read() to send current location by default\n\n        resource.read = function () {\n          var $this = this,\n              args = _normalizeArguments(arguments),\n              params = args[0].params || {};\n\n          if (!id && !params.lat && !params.lon && EVT.settings.geolocation) {\n            // If geolocation setting is turned on, get current position\n            return Utils.getCurrentPosition().then(function (position) {\n              params.lat = position.coords.latitude;\n              params.lon = position.coords.longitude;\n              args[0].params = params;\n              return Resource.prototype.read.apply($this, args);\n            }, function (err) {\n              // Unable to get position, just inform the reason in the console.\n              Logger.info(err);\n              return Resource.prototype.read.apply($this, args);\n            });\n          } else {\n            return Resource.prototype.read.apply($this, args);\n          }\n        };\n\n        return resource;\n      }\n    };\n  }); // ## FACEBOOK.JS\n  // **The Facebook module exports wrapped *login*, *logout* and *init* methods\n  // from the Facebook SDK, always returning Promises.**\n\n  define('social/facebook', ['promise', 'utils'], function (Promise, Utils) {\n    'use strict';\n    /*global FB*/\n    // Load Facebook SDK asynchronously. This means that by default\n    // it is not bundled with EvrythngJS, and is only loaded if an application\n    // needs Facebook authentication.\n    // The *init()* method also gets the current user information in one\n    // is already logged in.\n\n    function init(appId, config) {\n      // Return promise and resolve once user status is retrieved.\n      return new Promise(function (resolve) {\n        // Notice that the FB SDK only works in the browser. Thus, an Evrtyhng\n        // application cannot use Facebook authentication if it is not intended\n        // to run in the browser, as well.\n        window.fbAsyncInit = function () {\n          FB.init(Utils.extend({\n            appId: appId,\n            version: 'v2.8'\n          }, config, true)); // Get Login status and user info if connected. Build response as we\n          // fetch more information.\n\n          FB.getLoginStatus(function (response) {\n            /*response = authResponse + status*/\n            _getUser(response).then(function (userResponse) {\n              /*userResponse = authResponse + status + user*/\n              resolve(userResponse);\n            });\n          });\n        }; // Inject Facebook SDK script in document (see\n        // [Facebook Developer Docs](https://developers.facebook.com/docs/javascript/quickstart/v2.0)).\n\n\n        (function (d, s, id) {\n          var js,\n              fjs = d.getElementsByTagName(s)[0];\n\n          if (d.getElementById(id)) {\n            return;\n          }\n\n          js = d.createElement(s);\n          js.id = id;\n          js.src = \"//connect.facebook.net/en_US/sdk.js\";\n          fjs.parentNode.insertBefore(js, fjs);\n        })(document, 'script', 'facebook-jssdk');\n      });\n    } // Invoke standard Facebook login popup, using specified options.\n\n\n    function login(options) {\n      // Return promise and resolve once user info is retrieved.\n      return new Promise(function (resolve, reject) {\n        FB.login(function (response) {\n          /*response = authResponse + status*/\n          _getUser(response).then(function (userResponse) {\n            if (userResponse.user) {\n              /*userResponse = authResponse + status + user*/\n              resolve(userResponse);\n            } else {\n              // Reject login promise if the user canceled the FB login.\n              reject(userResponse);\n            }\n          });\n        }, options);\n      });\n    } // Invoke Facebook's logout and return promise.\n\n\n    function logout() {\n      return new Promise(function (resolve) {\n        FB.logout(resolve);\n      });\n    } // Fetch user info from Facebook if user is successfully connected.\n\n\n    function _getUser(response) {\n      if (response.status == 'connected') {\n        // Return a Promise for the response with user details.\n        return new Promise(function (resolve) {\n          // Until here, `response` was FB's auth response. Here\n          // we start to build bigger response by appending the Facebook's\n          // user info in the `user` property.\n          FB.api('/me', {\n            fields: ['id', 'first_name', 'last_name', 'gender', 'link', 'picture', 'locale', 'name', 'timezone', 'updated_time', 'verified'].toString()\n          }, function (userInfo) {\n            resolve(Utils.extend(response, {\n              user: userInfo\n            }));\n          });\n        });\n      } else {\n        // Return an already resolved promise.\n        return new Promise(function (resolve) {\n          resolve(response);\n        });\n      }\n    } // Expose only the higher level methods.\n\n\n    return {\n      init: init,\n      login: login,\n      logout: logout\n    };\n  }); // ## AUTHENTICATION.JS\n  // **Authentication provides a complete abstraction layer on top of\n  // the provided *'/auth/...'* endpoints in the REST API. Logging in with\n  // Evrythng or Facebook uses the same method and provide a similar response.**\n  // **Authentication with Facebook needs an app that has been created using the\n  // `facebook: true` option, which will load and init the Facebook SDK.**\n\n  define('authentication', ['core', 'promise', 'social/facebook', 'utils', 'logger'], function (EVT, Promise, Facebook, Utils, Logger) {\n    'use strict'; // Login into Evryhtng. This method is attached to the `EVT.App` API methods.\n    // Currently allowed authentication methods are **evrythng** and **facebook**.\n    // The login  accepts:\n    // - _**login('facebook')**: the normal third-party Facebook login pop-up_\n    // - _**login('facebook', fbOptions)**: use fbOptions to pass facebook scope\n    // permissions (see the\n    // [Facebook login API reference](https://developers.facebook.com/docs/reference/javascript/FB.login/v2.0))._\n    // - _**login('facebook', fbOptions, successCb, errorCb)**: same as previous,\n    // with callbacks_\n    // - _**login('facebook', successCb, errorCb)**: no custom Facebook options_\n    // - _**login('evrythng', evtCredentials)**: evtCredentials is an object with\n    // `email` or `id` and `password` properties_\n    // - _**login('evrythng', evtCredentials, successCb, errorCb)**: same as previous,\n    // with callbacks_\n    // The *evrythng* login methods allow to omit the first parameter. Thus, the\n    // following authenticates with Evrythng:\n    // ```\n    //  app.login({\n    //    email/id: \"userEmailOrId\",\n    //    password: \"pass\"\n    //  });\n    // ```\n\n    function login(type, customOptions, successCallback, errorCallback) {\n      var successCb = successCallback,\n          errorCb = errorCallback;\n\n      if (!type) {\n        throw new TypeError('Credentials (for Evrythng) or type (for Third party) are missing.');\n      } // Authenticate using third parties' OAuth.\n\n\n      if (Utils.isString(type)) {\n        if (type === 'facebook') {\n          return _loginFacebook.call(this, customOptions, successCb, errorCb);\n        } else if (type === 'evrythng') {\n          return _loginEvrythng.call(this, customOptions, successCb, errorCb);\n        }\n        /*TODO: add more authentication methods here.*/\n\n      } else {\n        // Evrythng login does not need first param. Simply call *_loginEvrythng()*\n        // with shifted arguments.\n        return _loginEvrythng.call(this, type, customOptions, successCb);\n      }\n    } // Login with Facebook. Custom Options are optional.\n    // **Default Facebook scope permission is simply *'email'*. If your application\n    // needs more than that, please read about Facebook login options and permissions\n    // on their\n    // [Developer Docs](https://developers.facebook.com/docs/reference/javascript/FB.login/v2.0)**.\n\n\n    function _loginFacebook(customOptions, successCallback, errorCallback) {\n      var options = {\n        scope: 'email'\n      },\n          $this = this; // If there are no facebook custom options, callbacks can start in first param.\n\n      if (Utils.isFunction(customOptions) || customOptions === null) {\n        var tmp = successCallback;\n        successCallback = customOptions;\n        errorCallback = tmp;\n      } else if (Utils.isObject(customOptions)) {\n        // If there are custom FB options, use this instead of the defaults.\n        options = customOptions;\n      } // Return promise and resolve only once authenticated with EVRYTHNG.\n\n\n      return new Promise(function (resolve, reject) {\n        // Login using Facebook with options above.\n        Facebook.login(options).then(function (userResponse) {\n          // If successful, authenticate with Evrythng, apply *successCb* and resolve\n          // promise. Our own *Facebook.login()* method (defined in the [`social/facebook`\n          // module](social/facebook.html)) already resolves with the user information.\n          // In this case, we add Evrythng access data to this already wrapped response.\n          authFacebook.call($this, userResponse).then(function (fullResponse) {\n            if (successCallback) {\n              Logger.warnCallbackDeprecation();\n              successCallback(fullResponse);\n            }\n\n            resolve(fullResponse);\n          });\n        }, function (response) {\n          // Login was not successful, apply *errorCb* and reject promise. Response\n          // has Facebook's *authResponse* and *status* objects.\n          if (errorCallback) {\n            Logger.warnCallbackDeprecation();\n            errorCallback(response);\n          }\n\n          reject(response);\n        });\n      });\n    } // Login with Evrythng using either the *email* or *id* properties.\n\n\n    function _loginEvrythng(credentials, successCallback, errorCallback) {\n      if (!credentials || Utils.isFunction(credentials)) {\n        throw new TypeError('Credentials are missing.');\n      } // Send the authentication request to the REST API, which is a Promise.\n      // Note that the context is passed from the above *app.login()* method\n      // until the raw call in order to pass the correct scope's Api Key.\n\n\n      return _authEvrythng.call(this, credentials).then(function (userResponse) {\n        // Login was successful, apply callback and propagate response to the\n        // next promise handler.\n        if (successCallback) {\n          Logger.warnCallbackDeprecation();\n          successCallback(userResponse);\n        }\n\n        return userResponse;\n      }, function (response) {\n        // Login was not successful, call error callback and re-throw error.\n        if (errorCallback) {\n          Logger.warnCallbackDeprecation();\n          errorCallback(response);\n        }\n\n        throw response;\n      });\n    } // Send authentication request with the Facebook auth token. This method is\n    // used on explicit login and when Facebook is initialized in the `EVT.App`\n    // constructor.\n\n\n    function authFacebook(response) {\n      var $this = this;\n      return EVT.api({\n        url: '/auth/facebook',\n        method: 'post',\n        data: {\n          access: {\n            token: response.authResponse.accessToken\n          }\n        },\n        authorization: this.apiKey\n      }).then(function (access) {\n        // Create User Scope with the user information and Api Key returned\n        // from the REST API.\n        var user = new EVT.User({\n          id: access.evrythngUser,\n          apiKey: access.evrythngApiKey\n        }, $this); // Fetch user dto from the platform and then\n        // return initial response\n        // TODO: Introduce proper read when DEV-190 merged\n\n        return EVT.api({\n          url: '/users/' + user.id,\n          authorization: user.apiKey\n        }).then(function (userDetails) {\n          // Prepare resolve object. Move Facebook user data to\n          // 'user.facebook' object\n          Utils.extend(user, {\n            facebook: response.user\n          }, true); // Merge user data from the platform to User Scope\n\n          Utils.extend(user, userDetails, true);\n          response.user = user;\n          return response;\n        });\n      });\n    } // Send authentication request using Evrythng credentials.\n\n\n    function _authEvrythng(credentials) {\n      var $this = this;\n      return EVT.api({\n        url: '/auth/evrythng',\n        method: 'post',\n        data: credentials,\n        authorization: this.apiKey\n      }).then(function (access) {\n        // Once it is authenticated, get this user information as well.\n        return EVT.api({\n          url: '/users/' + access.evrythngUser,\n          authorization: access.evrythngApiKey\n        }).then(function (userInfo) {\n          // Keep nested success handler because we also need the *access*\n          // object returned form the previous call to create the User Scope.\n          var userObj = Utils.extend(userInfo, {\n            id: access.evrythngUser,\n            apiKey: access.evrythngApiKey\n          }); // Create User Scope\n\n          var user = new EVT.User(userObj, $this);\n          return {\n            user: user\n          };\n        });\n      });\n    } // The *logout()* method behaves similarly to *login()*. The user should\n    // specify the type of logout they want (**_evrythng_ is default**).\n    // If an application logs in with Facebook, and simply logs out of\n    // Evrythng, then the Facebook user will continue connected until its FB\n    // token expires (which is most of the times not what you want).\n    // **As a good practice, if you log into an app with Facebook, also log\n    // out with Facebook. This allows app users to switch Facebook accounts.**\n\n\n    function logout(type, successCallback, errorCallback) {\n      if (type && Utils.isString(type)) {\n        if (type === 'facebook') {\n          return _logoutFacebook.call(this, successCallback, errorCallback);\n        } else if (type === 'evrythng') {\n          return _logoutEvrythng.call(this, successCallback, errorCallback);\n        }\n      } else {\n        return _logoutEvrythng.call(this, type, successCallback);\n      }\n    } // Logging out with Facebook, logs out out from Facebook and also from\n    // Evrythng.\n\n\n    function _logoutFacebook(successCallback, errorCallback) {\n      var $this = this;\n      return Facebook.logout().then(function () {\n        // If successful (always), also logout from Evrythng.\n        return _logoutEvrythng.call($this, successCallback, errorCallback);\n      });\n    }\n\n    function _logoutEvrythng(successCallback, errorCallback) {\n      return EVT.api({\n        url: '/auth/all/logout',\n        method: 'post',\n        authorization: this.apiKey\n      }).then(function (response) {\n        if (successCallback) {\n          Logger.warnCallbackDeprecation();\n          successCallback(response);\n        }\n\n        return response;\n      }, function (err) {\n        // If the logout from Evrythng fails, by some reason, throw error\n        // which would go to the promise error handler of the caller.\n        if (errorCallback) {\n          Logger.warnCallbackDeprecation();\n          errorCallback(err);\n        }\n\n        throw err;\n      });\n    } // Expose only the higher level methods.\n\n\n    return {\n      login: login,\n      logout: logout,\n      authFacebook: authFacebook\n    };\n  }); // ## APPLICATION.JS\n  // **Here it is defined the ApplicationScope or `EVT.App`. EVT.App\n  // is a sub-class of scope and it defines the public API that an App Api Key\n  // can access to.**\n  // An Application scope currently has access to:\n  // - Product resource (`R`)\n  // - Action resource (`C`) - Scans only\n  // - App User resource (`C`)\n  // - Login\n\n  define('scope/application', ['core', './scope', 'entity/product', 'entity/action', 'entity/user', 'entity/place', 'authentication', 'social/facebook', 'utils', 'logger'], function (EVT, Scope, Product, Action, User, Place, Authentication, Facebook, Utils, Logger) {\n    'use strict'; // Application Scope constructor. It can be called with the parameters:\n    // - _**new EVT.App(apiKey)** - API Key string_\n    // - _**new EVT.App(options)** - Options object should contain `apiKey`,\n    // and optionally `facebook` boolean. Passing `facebook: true` automatically\n    // initializes Facebook SDK with this application's FB App Id - setup in\n    // EVRYTHNG's Dashboard Project Preferences._\n\n    var ApplicationScope = function ApplicationScope(obj, parentScope) {\n      var $this = this; // Setup base Scope with the provided API Key.\n\n      if (Utils.isObject(obj)) {\n        Scope.call(this, obj.apiKey);\n        Utils.extend(this, obj, true);\n      } else {\n        Scope.call(this, obj);\n      } // Set parent scope\n\n\n      if (parentScope instanceof Scope) {\n        this.parentScope = parentScope;\n      } // Get app information asynchronously from the Engine using already\n      // defined scope. Use **new EVT.App('apiKey').$init.then(success)** if need\n      // to wait for app information.\n\n\n      this.$init = this.$init.then(function () {\n        return EVT.api({\n          url: '/applications/me',\n          authorization: $this.apiKey\n        });\n      }).then(function (application) {\n        delete application.appApiKey;\n        return application;\n      }).then(Utils.extendCurried($this)).catch(function () {\n        var error = 'There is no application with this API Key.';\n        Logger.error(error);\n        throw new Error(error);\n      }).then(function (app) {\n        // If using Facebook, the $init promise is only resolved after FB\n        // is initialized and user login status is retrieved. In this situation,\n        // the resolved object of `$init` is a wrapped object:\n        // ```\n        //  {\n        //    status: <Facebook's connected status>,\n        //    authResponse: <Facebook's auth response>,\n        //    user: {\n        //      facebook: { <Facebook's user info>}\n        //      <Evrythng's user information>\n        //    },\n        //    app: {\n        //      <Evrythng's app information>\n        //    }\n        //  }\n        // ```\n        if (obj.facebook) {\n          if (!app.socialNetworks || !app.socialNetworks.facebook) {\n            Logger.error('The Facebook configuration for this application is incorrect.');\n            return;\n          } // Get Facebook App ID from the Evrythng App social networks list.\n\n\n          return Facebook.init(app.socialNetworks.facebook.appId, obj.facebook).then(function (response) {\n            if (response.status === 'connected') {\n              // If user is connected with Facebook, return a promise with his details.\n              return Authentication.authFacebook.call($this, response);\n            } else {\n              return response;\n            }\n          }).then(Utils.extendCurried({\n            app: app\n          }));\n        } else {\n          // If not using Facebook, simply return app details after they are received.\n          return app;\n        }\n      });\n    }; // Setup Scope inheritance.\n\n\n    ApplicationScope.prototype = Object.create(Scope.prototype);\n    ApplicationScope.prototype.constructor = ApplicationScope; // Implement Public API by extending the prototype.\n    // By default all resource constructors are themselves factory functions\n    // that are called by the scopes, can receive an ID and return a Resource.\n    // However, in some situations in our API, the output of different endpoints can\n    // be the same. Thus we need to setup the resource constructor to use a certain\n    // path, and return the correct factory function. This is what happens here with the\n    // **appUser()** resource constructor.\n\n    Utils.extend(ApplicationScope.prototype, {\n      product: Product.resourceConstructor,\n      action: Action.resourceConstructor,\n      // Setup AppUser resource to use *'/auth/evrythng/users'* instead\n      // of the default *'/users'*. Both endpoints return a list of User entities.\n      appUser: User.resourceConstructor('/auth/evrythng/users'),\n      place: Place.resourceConstructor,\n      login: Authentication.login\n    }, true); // Attach ApplicationScope class to the EVT module.\n\n    return EVT.App = ApplicationScope;\n  }); // ## ACCESS.JS\n  // **The Access help to create a new Application User access for another Application User\n  // by specifying their email address and role to be assigned**\n\n  define('entity/access', ['core', './entity', 'resource', 'utils'], function (EVT, Entity, Resource, Utils) {\n    'use strict'; // Setup Access inheritance from Entity.\n\n    var Access = function Access() {\n      Entity.apply(this, arguments);\n    };\n\n    Access.prototype = Object.create(Entity.prototype);\n    Access.prototype.constructor = Access; // Attach class to EVT module.\n\n    EVT.Entity.Access = Access;\n    return {\n      'class': Access,\n      resourceConstructor: Resource.constructorFactory('/accesses', EVT.Entity.Access)\n    };\n  }); // ## LOCATION.JS\n  // **The Location Entity represents a location in the Engine. It inherits\n  // from Entity and overload the resource's *update()* method to allow\n  // empty parameters (no payload).**\n\n  define('entity/location', ['core', './entity', 'resource', 'utils', 'logger'], function (EVT, Entity, Resource, Utils, Logger) {\n    'use strict'; // Setup Location inheritance from Entity.\n\n    var Location = function Location() {\n      Entity.apply(this, arguments);\n    };\n\n    Location.prototype = Object.create(Entity.prototype);\n    Location.prototype.constructor = Location; // Attach class to EVT module.\n\n    EVT.Entity.Location = Location; // The location update normalization of arguments allows to\n    // make easier and more intuitive calls, such as:\n    // - Single location update:\n    // ```\n    //  thng.location().update({\n    //    position: GeoJSON\n    //  });\n    // ```\n    // - Multi location update:\n    // ```\n    //  thng.location().update([\n    //    {\n    //      position: GeoJSON\n    //    },\n    //    {\n    //      position: GeoJSON,\n    //      timestamp: Timestamp\n    //    }\n    // ]);\n    // ```\n\n    function _normalizeArguments(args) {\n      var data = args[0];\n\n      if (Utils.isObject(data)) {\n        // Convert single object to array\n        args[0] = [data];\n      } else if (!data || Utils.isFunction(data)) {\n        // Add empty data object\n        args = Array.prototype.slice.call(args, 0);\n        args.unshift([]);\n      }\n\n      return args;\n    }\n\n    return {\n      'class': Location,\n      resourceConstructor: function resourceConstructor() {\n        var path = this.resource.path + '/location',\n            args = arguments[0] || []; // This endpoint is a bit special, does not allow getting location by ID\n\n        if (Utils.isString(args) || Utils.isObject(args) && Utils.isString(args.id)) {\n          throw new TypeError('IDs not allowed here');\n        }\n\n        var resource = new Resource(this.resource.scope, path, EVT.Entity.Location); // Overload resource update() to send current location if none provided\n\n        resource.update = function () {\n          var $this = this,\n              args = _normalizeArguments(arguments);\n\n          if (args[0].length === 0 && EVT.settings.geolocation) {\n            // If geolocation setting is turned on, get current position\n            return Utils.getCurrentPosition().then(function (position) {\n              args[0] = [{\n                position: {\n                  type: \"Point\",\n                  coordinates: [position.coords.longitude, position.coords.latitude]\n                }\n              }];\n              return Resource.prototype.update.apply($this, args);\n            }, function (err) {\n              // Unable to get position, just inform the reason in the console.\n              Logger.info(err);\n              return Resource.prototype.update.apply($this, args);\n            });\n          } else {\n            return Resource.prototype.update.apply($this, args);\n          }\n        };\n\n        return resource;\n      }\n    };\n  }); // ## SHARE.JS\n  // ** help an Application User to share access to Thngs they are scoped to with other Application Users within the same Platform account.**\n\n  define('entity/share', ['core', './entity', 'scope/scope', 'resource', 'utils'], function (EVT, Entity, Scope, Resource, Utils) {\n    'use strict'; // Setup Share inheritance from Entity.\n\n    var Share = function Share() {\n      Entity.apply(this, arguments);\n    };\n\n    Share.prototype = Object.create(Entity.prototype);\n    Share.prototype.constructor = Share; // Attach class to EVT module.\n\n    EVT.Entity.Share = Share;\n    return {\n      'class': Share,\n      //../thngs/:thngId/shares\n      resourceConstructor: function resourceConstructor() {\n        var scope = this.resource.scope;\n        var path = this.resource.path + '/shares';\n        return new Resource(scope, path, EVT.Entity.Share);\n      }\n    };\n  }); // ## THNG.JS\n  // **The Thng is a simple Entity subclass that provides a nested\n  // Property Resource and a direct method to read the Thng's Product.**\n\n  define('entity/thng', ['core', './entity', 'resource', './property', './action', './location', './share', 'utils'], function (EVT, Entity, Resource, Property, Action, Location, Share, Utils) {\n    'use strict'; // Setup Thng inheritance from Entity.\n\n    var Thng = function Thng() {\n      Entity.apply(this, arguments);\n    };\n\n    Thng.prototype = Object.create(Entity.prototype);\n    Thng.prototype.constructor = Thng; // When not using `fetchCascade`, this method allows to easily\n    // fetch the Product entity of this Thng. It fowards the call\n    // to this thng's scope's product resource.\n\n    function readProduct() {\n      if (!this.product) {\n        throw new Error('Thng does not have a product.');\n      }\n\n      if (!this.resource) {\n        throw new Error('Thng does not have a resource.');\n      }\n\n      return this.resource.scope.product(this.product).read();\n    } // Extend Thng API by exposing a Property Resource, allowing to\n    // manage the properties of this product with a resource pattern.\n    // Expose an Action resource as well, for managing Thngs actions.\n    // Also attach the *readProduct()* method to every Thng.\n\n\n    Utils.extend(Thng.prototype, {\n      property: Property.resourceConstructor,\n      action: Action.resourceConstructor,\n      location: Location.resourceConstructor,\n      share: Share.resourceConstructor,\n\n      /*TODO API not very consistent - thng.product().read/update() better?*/\n      readProduct: readProduct\n    }, true); // Attach class to EVT module.\n\n    EVT.Entity.Thng = Thng;\n    return {\n      'class': Thng,\n      resourceConstructor: Resource.constructorFactory('/thngs', EVT.Entity.Thng, ['property', 'action', 'location', 'share'])\n    };\n  }); // ## ACTIONTYPE.JS\n  // **The ActionType Entity represents an action type in the Engine. It inherits\n  // from Entity and overload the resource's *create()* method to allow\n  // empty parameters (no payload).**\n\n  define('entity/actionType', ['core', './entity', 'resource', 'utils', 'logger'], function (EVT, Entity, Resource, Utils, Logger) {\n    'use strict'; // Setup Action inheritance from Entity.\n\n    var ActionType = function ActionType() {\n      Entity.apply(this, arguments);\n    };\n\n    ActionType.prototype = Object.create(Entity.prototype);\n    ActionType.prototype.constructor = ActionType; // Normalize arguments for single request. Override resource\n    // url to use action types root path and use name filter.\n    // Extend params if user defines other params.\n\n    function _normalizeArguments(obj) {\n      var args = arguments;\n\n      if (!obj || Utils.isFunction(obj)) {\n        args = Array.prototype.slice.call(arguments, 0);\n        args.unshift({});\n      } // Split full path (/actions/_custom) - we get three parts:\n      // 1) empty, 2) root path and 3) encoded action type name\n\n\n      var url = this.path.split('/');\n      args[0].url = '/' + url[1];\n      args[0].params = Utils.extend(args[0].params, {\n        filter: {\n          name: decodeURIComponent(url[2])\n        }\n      });\n      return args;\n    } // Attach class to EVT module.\n\n\n    EVT.Entity.ActionType = ActionType;\n    return {\n      'class': ActionType,\n      resourceConstructor: function resourceConstructor(actionTypeName) {\n        var path = '/actions',\n            resource;\n\n        if (actionTypeName) {\n          if (Utils.isString(actionTypeName)) {\n            path += '/' + encodeURIComponent(actionTypeName);\n          } else {\n            throw new TypeError('Action type must be a key/name string');\n          }\n        }\n\n        resource = new Resource(this, path, EVT.Entity.ActionType); // Action types are a bit special, has there is no GET method available.\n        // In order to do so, we need to make a filtered request to the root path,\n        // and parse the response normally. An empty result list, means not found.\n\n        resource.read = function () {\n          if (!actionTypeName) {\n            return Resource.prototype.read.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n\n            return Resource.prototype.read.apply(this, args).then(function (actionTypes) {\n              if (!actionTypes.length) {\n                // Fake 404\n                var error = {\n                  status: 404,\n                  errors: [\"The action type was not found.\"],\n                  url: path\n                };\n                Logger.error(error);\n                throw error;\n              } else {\n                return actionTypes[0];\n              }\n            });\n          }\n        };\n\n        return resource;\n      }\n    };\n  }); // ## COLLECTION.JS\n  // **The Collection is a simple Entity subclass that provides a nested\n  // Thng Resource.**\n\n  define('entity/collection', ['core', './entity', 'resource', './action', 'utils'], function (EVT, Entity, Resource, Action, Utils) {\n    'use strict'; // Setup Collection inheritance from Entity.\n\n    var Collection = function Collection() {\n      Entity.apply(this, arguments);\n    };\n\n    Collection.prototype = Object.create(Entity.prototype);\n    Collection.prototype.constructor = Collection; // Custom nested resource constructor for Thngs of a Collection.\n\n    function thng(id) {\n      // To create nested Resources, the collection itself needs\n      // a resource.\n      if (!this.resource) {\n        throw new Error('This Entity does not have a Resource.');\n      }\n\n      var path = this.resource.path + '/thngs';\n      return Resource.constructorFactory(path, EVT.Entity.Thng).call(this.resource.scope, id);\n    } // Custom nested resource constructor for Collections of a Collection.\n\n\n    function collection(id) {\n      if (!this.resource) {\n        throw new Error('This Entity does not have a Resource.');\n      }\n\n      var path = this.resource.path + '/collections';\n      return Resource.constructorFactory(path, EVT.Entity.Collection).call(this.resource.scope, id);\n    } // Extend Collection API by exposing nested Resources.\n\n\n    Utils.extend(Collection.prototype, {\n      thng: thng,\n      collection: collection,\n      action: Action.resourceConstructor\n    }, true); // Attach class to EVT module.\n\n    EVT.Entity.Collection = Collection;\n    return {\n      'class': Collection,\n      resourceConstructor: Resource.constructorFactory('/collections', EVT.Entity.Collection, ['thng', 'collection', 'action'])\n    };\n  }); // ## PERMISSION.JS\n  // **Permission defines a unique endpoint permission assigned to a role.**\n\n  define('entity/permission', ['core', './entity', 'resource'], function (EVT, Entity, Resource) {\n    'use strict'; // Setup Permission inheritance from Entity.\n\n    var Permission = function Permission() {\n      Entity.apply(this, arguments);\n    };\n\n    Permission.prototype = Object.create(Entity.prototype);\n    Permission.prototype.constructor = Permission; // Attach class to EVT module.\n\n    EVT.Entity.Permission = Permission;\n    return {\n      'class': Permission,\n      resourceConstructor: function resourceConstructor() {\n        // TODO relax validation to support old permission API\n        // var args = arguments[0] || [];\n        //\n        // // Permission endpoint does not allow single resource ID.\n        // if (Utils.isString(args) ||\n        //   Utils.isObject(args) && Utils.isString(args.id)) {\n        //   throw new TypeError('IDs not allowed here');\n        // }\n        if (!this.resource) {\n          throw new Error('This Entity does not have a Resource.');\n        }\n\n        var path = this.resource.path + '/permissions',\n            scope = this.resource.scope;\n        return Resource.constructorFactory(path, EVT.Entity.Permission).call(scope);\n      }\n    };\n  }); // ## POLICY.JS\n  // **Policy defines the relationship between a role and schema.**\n\n  define('entity/policy', ['core', './entity', 'resource'], function (EVT, Entity, Resource) {\n    'use strict'; // Setup Policy inheritance from Entity.\n\n    var Policy = function Policy() {\n      Entity.apply(this, arguments);\n    };\n\n    Policy.prototype = Object.create(Entity.prototype);\n    Policy.prototype.constructor = Policy; // Attach class to EVT module.\n\n    EVT.Entity.Policy = Policy;\n    return {\n      'class': Policy,\n      resourceConstructor: function resourceConstructor(id) {\n        if (!this.resource) {\n          throw new Error('This Entity does not have a Resource.');\n        }\n\n        var path = this.resource.path + '/policies',\n            scope = this.resource.scope;\n        return Resource.constructorFactory(path, EVT.Entity.Policy).call(scope, id);\n      }\n    };\n  }); // ## ROLE.JS\n  // **Role defines a set of API access permissions, containing a nested\n  // Permission resource.**\n\n  define('entity/role', ['core', './entity', './permission', './policy', 'resource', 'utils'], function (EVT, Entity, Permission, Policy, Resource, Utils) {\n    'use strict'; // Setup Role inheritance from Entity.\n\n    var Role = function Role() {\n      Entity.apply(this, arguments);\n    };\n\n    Role.prototype = Object.create(Entity.prototype);\n    Role.prototype.constructor = Role; // Attach class to EVT module.\n\n    EVT.Entity.Role = Role; // Extend Role API.\n\n    Utils.extend(Role.prototype, {\n      permission: Permission.resourceConstructor,\n      policy: Policy.resourceConstructor\n    }, true);\n    return {\n      'class': Role,\n      resourceConstructor: Resource.constructorFactory('/roles', EVT.Entity.Role, ['permission', 'policy'])\n    };\n  }); // ## USER.JS\n  // **Here it is defined the UserScope or `EVT.User`. EVT.User\n  // is a sub-class of scope and it defines the public API that the\n  // user and its API Keys can access to.**\n  // A User scope currently has access to:\n  // - Product resource (`C`, `R`, `U`)\n  // - Thng resource (`C`, `R`, `U`)\n  // - ActionType resource (`R`)\n  // - Action resource (`C`, `R`)\n  // - Collection resource (`C`, `R`, `U`)\n  // - Logout\n  // - Update itself (the user information)\n  // - Role resource (`R`)\n  // - (`C`, `R`, `U` actions via products/thngs)\n  // - Accesses (`C`, `R`, `U`)\n\n  define('scope/user', ['core', './scope', 'entity/product', 'entity/access', 'entity/thng', 'entity/user', 'entity/actionType', 'entity/action', 'entity/collection', 'entity/place', 'entity/role', 'authentication', 'utils', 'logger'], function (EVT, Scope, Product, Access, Thng, User, ActionType, Action, Collection, Place, Role, Authentication, Utils, Logger) {\n    'use strict'; // User Scope constructor. It can be called with the parameters:\n    // - _**new EVT.User(apiKey, parentScope)** - API Key string.\n    // Optional parent scope._\n    // - _**new EVT.User(options, parentScope)** - Options object should\n    // contain `apiKey` and optionally user information (user entity retrieved\n    // from the engine). Optional parent scope._\n\n    var UserScope = function UserScope(obj, parentScope) {\n      var $this = this; // Setup base Scope with the provided API Key.\n\n      if (Utils.isObject(obj)) {\n        Scope.call(this, obj.apiKey); // Merge user information into the scope, as we do with the ApplicationScope.\n\n        Utils.extend(this, obj, true);\n      } else {\n        Scope.call(this, obj);\n      } // Store parent scope. *Currently not used.*\n\n\n      if (parentScope instanceof Scope) {\n        this.parentScope = parentScope;\n      }\n\n      this.$init = this.$init.then(function (access) {\n        return EVT.api({\n          url: '/users/' + access.actor.id,\n          authorization: $this.apiKey\n        });\n      }).then(Utils.extendCurried($this)).catch(function () {\n        var error = 'There is no user with this API Key';\n        Logger.error(error);\n        throw new Error(error);\n      });\n    }; // Setup Scope inheritance.\n\n\n    UserScope.prototype = Object.create(Scope.prototype);\n    UserScope.prototype.constructor = UserScope; // Allow to update the current user without an explicit API call. Simply update\n    // the user scope object and call update will make the request to update the user\n    // in the *'/users'* endpoint.\n\n    function update() {\n      var $this = this,\n          self = User.resourceConstructor().call(this, this.id);\n      return self.update.apply(self, arguments).then(function (updated) {\n        Utils.extend($this, updated, true);\n        return updated;\n      });\n    } // Implement Public API by extending the prototype.\n    // See explanation of resource constructors in ApplicationScope. The\n    // **thng()** resource builds a custom resource constructor by using\n    // the default *'/thngs'* endpoint.\n\n\n    Utils.extend(UserScope.prototype, {\n      product: Product.resourceConstructor,\n      access: Access.resourceConstructor,\n      thng: Thng.resourceConstructor,\n      actionType: ActionType.resourceConstructor,\n      action: Action.resourceConstructor,\n      collection: Collection.resourceConstructor,\n      place: Place.resourceConstructor,\n      role: Role.resourceConstructor,\n      logout: Authentication.logout,\n      update: update\n    }, true); // Attach UserScope class to the EVT module.\n\n    return EVT.User = UserScope;\n  }); // ## DEVICE.JS\n  // **Here it is defined the DeviceScope or `EVT.Device`. EVT.Device\n  // is a sub-class of scope and it defines the public API that the\n  // device can access to.**\n  // A Device scope currently has access to:\n  // - Thng resource (`R`, `U`)\n  // - (`C`, `R`, `U` properties/actions via thngs)\n\n  define('scope/device', ['core', './scope', 'entity/thng', 'utils', 'logger'], function (EVT, Scope, Thng, Utils, Logger) {\n    'use strict'; // Device Scope constructor. It can be called with the parameters:\n    // - _**new EVT.Device(options, parentScope)** - Options object should\n    // contain `apiKey` and optionally device information (thng entity retrieved\n    // from the engine). Optional parent scope._\n\n    var DeviceScope = function DeviceScope(obj, parentScope) {\n      var $this = this; // Setup base Scope with the provided API Key.\n\n      if (Utils.isObject(obj)) {\n        Scope.call(this, obj.apiKey); // Merge device information into the scope, as we do with the UserScope.\n\n        Utils.extend(this, obj, true);\n      } else {\n        throw new TypeError('DeviceScope constructor should be called with object' + ' containing API Key and ID of device.');\n      } // Store parent scope. *Currently not used.*\n\n\n      if (parentScope instanceof Scope) {\n        this.parentScope = parentScope;\n      }\n\n      this.$init = this.$init.then(function (access) {\n        return Thng.resourceConstructor.call($this, access.actor.id).read();\n      }).then(Utils.extendCurried($this)).catch(function () {\n        var error = 'There is no device with this API Key.';\n        Logger.error(error);\n        throw new Error(error);\n      });\n    }; // Setup Scope inheritance.\n\n\n    DeviceScope.prototype = Object.create(Scope.prototype);\n    DeviceScope.prototype.constructor = DeviceScope; // Allow to update the current device without an explicit API call. Simply update\n    // the device scope object and call update will make the request to update the device\n    // in the *'/thngs'* endpoint.\n\n    function update() {\n      var $this = this,\n          self = Thng.resourceConstructor.call(this, this.id);\n      return self.update.apply(self, arguments).then(function (updated) {\n        Utils.extend($this, updated, true);\n        return updated;\n      });\n    } // The device property resource is in fact just an alias for the\n    // inherited Thng.property() resource.\n\n\n    function property() {\n      var self = Thng.resourceConstructor.call(this, this.id);\n      return self.property.apply(self, arguments);\n    } // The device action resource is in fact just an alias for the\n    // inherited Thng.action() resource.\n\n\n    function action() {\n      var self = Thng.resourceConstructor.call(this, this.id);\n      return self.action.apply(self, arguments);\n    } // Implement Public API by extending the prototype.\n    // See explanation of resource constructors in ApplicationScope. The\n    // **thng()** resource builds a custom resource constructor by using\n    // the default *'/thngs'* endpoint.\n\n\n    Utils.extend(DeviceScope.prototype, {\n      property: property,\n      action: action,\n      update: update\n    }, true); // Attach DeviceScope class to the EVT module.\n\n    return EVT.Device = DeviceScope;\n  }); // # **[EVRYTHNG](https://www.evrythng.com)'s JavaScript SDK**\n  // ## EVRYTHNG.JS\n  // EvrythngJS uses AMD ([RequireJS](http://requirejs.org/)) to load all of its\n  // building modules.\n  // This is the higher level module that requires the `EVT.App`, `EVT.User` and\n  // and `EVT.Device` classes representing the Application, User and Device scopes respectively.\n  // All other modules are loaded as dependencies of these.\n  // ### UMD\n  // EvrythngJS is wrapped in a [UMD](https://github.com/umdjs/umd) definition which makes it\n  // available as an **AMD** (RequireJS) module, **CommonJS** (Node.js) or **browser globals**.\n  // EvrythngJS bundle also includes:\n  // - [Almond](https://github.com/jrburke/almond): a minimal AMD script loader\n  // - [NPO](https://github.com/getify/native-promise-only): an ES6 Promise polyfill,\n  // strict Promises/A+ (1.1) implementation\n  // - [Regenerator](https://github.com/facebook/regenerator): an ES6 Generator + ES7 Async-await\n  // functions polyfill\n\n  define('evrythng', ['core', 'api', 'scope/application', 'scope/user', 'scope/device'], function (EVT) {\n    'use strict'; // Return fully built EVT module.\n\n    return EVT;\n  }); //Use almond's special top-level, synchronous require to trigger factory\n  //functions, get the final module value, and export it as the public\n  //value.\n\n  return require('evrythng');\n});","map":null,"metadata":{},"sourceType":"script"}